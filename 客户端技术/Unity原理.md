## Unity原理解析


组件
--------------

### 1. Unity脚本的生命周期

（1）Reset：当Scripts第一次绑定到物体上或者点击Reset按钮的时候会触发，且只在Editor的模式下触发，游戏打包的时候并不会触发。

（2）Awake：当脚本实例在游戏运行被载入的时候运行，一般为了初始化游戏变量和游戏状态，注意，无论函数是否被激活，Awake都会执行。

（3）OnEable：在游戏对象是可激活状态的时候会调用。

（4）Start：也是为了初始化变量的方法，但是和Awake有些许不同。首先，Awake是在项目初始化的时候调用的，但是Start可能在初始化之后调用，所以如果把一些状态变量放在Start中进行初始化，会很不安全，因为可能会有别的函数在Start之前就执行，造成一些空引用的问题。其次，如果不是处在激活的状态，Start是不会被调用的，但是Awake无论是不是激活都会被调用。

（5）FixedUpdate：所有的物理行为的每帧更新的逻辑都应该放在这里，因为这个是固定间隔的帧执行的，而普通的Update每一帧之间的间隔是不一样的，我们希望施加在物体上的力是均匀的，否则会出现卡顿的情况。实现原理：判断两帧之间的间隔deltaTime，加到Time内；如果Time-FixedTime >FixedDeltaTime，则执行FixedUpdate，并将FixedDeltaTime加到FixedTime；否则不执行FixedUpdate。

（6）OnTrigger：触发器行为  OnCollision：碰撞行为  OnMouse：点击输入行为

（7）Update：每一帧进行调用，是实现游戏逻辑的主要方法。

（8）LateUpdate：在所有Update方法执行之后执行，一般用于摄像机的跟随移动。

（9）OnGUI：处理GUI数据，也是每一帧执行一次

（10）OnDisable：在对象被取消活跃状态的时候响应，和OnEnable相对应，但与此同时对象再次被激活的时候，OnEnable也会再次响应。

（11）OnDestroy：在对象被销毁的时候调用，但是如果一开始对象就处于不激活状态然后被销毁了，就不会调用这个函数。

### 2. NavMesh导航系统

导航烘焙：通过导航面板（Window -> AI -> Navigation）规划场景中哪里可以去哪里不能去。（1）选择场景中，将地形、场景相关的游戏物体设置为Static模式，这是烘培的前提（2）直接选择子栏目Bake，点击Bake按钮。（3）场景中部分区域呈现成蓝色，意味着烘培成功，蓝色就是角色可以前往的地方。一定要把场景Static打开，静态才能导航烘焙。

NavMeshAgent 导航网格代理：添加这个导航代理组件的游戏物体，身上会增加一个圆柱体形状的碰撞体，可以设置移动物体的属性。

NavMeshObctacle 导航网格障碍物：是NavMeshAgent需要避开的障碍物。NavMeshObstacle 为圆柱形，能够以特定的速度沿着导航网格的表面移动。默认情况下，障碍物只会影响agent 的“规避”行为，并不会影响其寻路行为。这意味着 agent 将在寻路时忽略障碍物，但需要在沿路径移动时绕过障碍物。如果已启用“Carve雕刻”，障碍物会在导航网格中创建一个临时的“孔”。寻路时可识别该孔，因此所确定的路径将避开障碍物。这意味着如果障碍物阻挡了狭窄的间隙，寻路功能会寻找前往目的地的替代路线。如果没有雕刻功能，agent会前往空隙处，但只能在清除障碍物后才能通过。Carve: 是否重新渲染，不勾上的话只有离agent近的时候才会参与计算，如果障碍物是实时运动的，那就不要选，不然消耗资源 。

OffMeshLink 网格外连接：在平面导航网格外部移动的链接，将两个分开网格建立链接。

底层实现基于A*寻路算法和网格图。


### 3. 渲染管线

内置渲染管线（Build-In Render）：这是Unity最早的渲染管线，也是默认的渲染管线，提供了一套简单的渲染流程，但功能较为基础，对于一些高级的图形效果可能无法实现。

可编程渲染管线技术SRP（Scriptable Render Pipline）：可以在Unity通过C#脚本调用API配置或执行渲染命令的方式来实现渲染流程，SRP将这些命令传递给Unity底层图形体系结构（low-level graphics architecture），然后再将指令发送给图形API（Graphics API），最终由GPU进行处理，SRP 技术可以强化通用渲染管线 (URP) 和高清渲染管线 (HDRP)。URP和HDRP建立在SRP之上，还可以在 SRP 之上创建自己的自定义渲染管线。

通用渲染管线URP（Universal Render Pipeline）：从Unity 2019.3版本开始，Unity引入了通用渲染管线URP，它是一种快速的单通道前向渲染器，主要设计用于不支持计算着色器技术的低端设备，还可为中端设备（如游戏主机和PC）提供更高质量的图形性能。优势：（1）URP是单Pass前向渲染管线，所有的光源处理都可以在一个DrawCall中完成，而内置管线是多Pass,可选前向渲染管线和延迟渲染管线。（2）传统内置渲染管线中的批处理有着诸多限制，特别是动态批处理，这在底层渲染优化机制SRP Batcher 中得到了彻底优化，只要是用一个着色器变体的物体都可以批处理到一起。（3）可扩展性得到了提升

HDRP 高清渲染管线（High Definition Render Pipeline）：这是Unity的高质量渲染管线，主要针对高端设备，例如最新的智能手机、游戏主机和PC等。它提供了更高的视觉效果和更真实的图像表现，同时也需要更高的计算能力。

URP详细介绍：



### 4. 动画系统

序列帧：原理就是在很短的间隔内，按照一定的间隔拍摄连续的静态照片；内存占用高。

关键帧动画：每个关键帧定义了一个特定状态，关键帧间通过插值生成平滑过渡动画效果。

刚性层阶式动画：角色由一堆刚性部分建模而成，在关节位置容易产生裂缝。

蒙皮/骨骼动画：骨骼（skeleton）由刚性的骨头(bone）构建而成，这与刚性层阶式动画是一样的。称为皮肤的三角形mesh网格会绑定在这些骨骼上，其顶点随着关节（joint）的移动而移动，每个顶点可以按照权重绑定到多个关节，因此关节移动时，蒙皮可以自然的拉伸。

优缺点对比：（1） 帧动画。优点：性能好，直接换图即可，不用计算。缺点：内存高，动作分解了好多图片。（2）骨骼动画。优点：内存资源占用少，只有一个一个的骨骼，动画代码控制。缺点：动画需要代码计算，所以性能比帧动画要差。

Timeline：是Unity推出的一个资源整合工具。该工具可以给不同的游戏对象建立不同类型的轨道。每个轨道可以单独进行编辑，轨道内的不同资源可以有序的进行排列以及融合。

（1）Activation Track：对象激活与隐藏轨道，选择控制在Timeline上何时激活轨道。

（2）AnimationTrack：动画轨道，控制游戏物体的动画，允许直接导入动画片段clip。

（3）AudioTrack：声音轨道，允许导入现有音频资源片段，做出编辑。

（4）Signal Track：信号轨道，包括信号资源，信号发射器和信号接收器，它其实就是一个Event，作用就是在单独轨道上面添加事件点，在某一帧执行某个方法。

Animation：

每一个动画都是一个AnimationClip，存放在Assets文件夹里，它是一段预定义的动画序列，包含了对象在一段时间内的位置、旋转、缩放等变化。

动画组件（Animation Component）：实际播放动画的是物体上的Animator组件，应用于游戏对象中控制对象的动画播放。注意动画的优先级比代码要高。

动画过渡（Transitions）：用于动画与动画间的转化。状态控制参数是用于控制Transition的发生的。比如只有当我们按下空格时才要过渡到跳跃动画。

其他：骨骼动画系统、动画事件、动画曲线编辑、Blend Trees。

### 5. meta文件的作用

每个meta文件中一定会有两个属性：（1）uuid：该资源的唯一标识符，meta文件创建时随机生成。（2）ver：meta文件的版本号，由资源对应的meta类定义，用于判断资源在不同版本的编辑器中是否需要重新导入。

不能随意删除meta文件：uuid是资源的唯一标识符，资源文件直接的引用都是依赖于uuid的，一旦删除了meta文件，那么这个资源的uuid就发生了变化，之后使用这个资源的地方就会遇到无法找到资源的问题。


UGUI：
--------------
锚点（anchors）：
是相对父节点的属性，决定了当屏幕分辨率发生改变的时候，UI的位置和大小如何变化。

中心点（pivot）：
是相对于节点本身的属性，Pivot点的坐标是一个归一化的2D模型坐标系下的坐标，决定了物体如何向两边延伸以及如何旋转。

尺寸变化量（sizeDelta）：
RectTransform的四个角相对于四个锚点的屏幕空间下的距离差。

anchoredPosition：
屏幕空间坐标系下，当前物体的pivot点相对于锚点的pivot点的距离。


Graphic：Graphic作为图像组件的基类,主要实现了网格与图像的生成/刷新方法。

EventSystem: UGUI事件管理系统,通过此系统完成我们所知的UI交互。
管理所有的输入检测模块(InputModule)并帧调用Module的执行(Process)
调动射线捕捉模块(Raycasters),为InputModule提供结果(具体本的触点所穿透的
对象信息)

UGUI是Unity引擎自带的UI系统，只能用于游戏UI功能，不能用于开发编辑器内置的用户界面。

#### 六大基本组件：

Canvas对象上依附的：（1）Canvas，画布组件，主要用于渲染UI控件。（2）Canvas Scaler，画布分辨率自适应组件，主要用于分辨率自适应。（3）Graphic Raycaster，射线事件交互组件，主要用于控制射线响应相关。（4）RectTransform，UI对象位置锚点控制组件，主要用于控制位置和对齐方式。EventSystem对象上依附的：（5）EventSystem，玩家输入事件响应系统。（6）Standalone Input Modul，独立输入模块组件，主要用于监听玩家操作。

#### Canvas的三种渲染方式：

（1）Screen Space – Overlay：屏幕空间，覆盖模式，UI始终在前。

（2）Screen Space – Camera：屏幕空间，摄像机模式，3D物体可以显示在UI之前。

（3）World Space：世界空间，3D模式。

三大基础控件：（1）Image，UGUI的图像组件，是UGUI用于显示精灵图片的关键组件，除了背景图等大图，一般都使用Image来显示UI中的图片元素，只有Sprite可以拖拽到Image组件中。（2）Text，用于显示文本，可以设置字体、字号、颜色、对齐方式等属性，并支持富文本格式。（3）RawImage控件：用于显示未经处理的原始图像，例如将图片作为背景或显示视频纹理等，用于显示大图（背景图，不需要打入图集的图，网络下载的图等）。

#### Image和Rawlmage的区别：

（1）渲染方式：Image组件使用Unity的UI系统进行渲染，支持图像的2D变换、填充类型、九宫格切片等功能，可以显示Sprite或Texture，支持更复杂的渲染效果，如颜色混合、填充、裁剪等，这些额外的渲染操作可能会增加性能开销。RawImage组件使用Unity的底层渲染系统，只能显示Texture，渲染方式相对较简单，通常只涉及纹理的绘制。

（2）纹理处理：Image组件会对纹理进行处理，使其适应UI元素的大小和变换。RawImage：RawImage组件直接使用原始的纹理数据，不对纹理进行处理或拉伸。

（3）功能和用途：Image通常用于显示UI界面中的静态图像，如图标、背景、按钮等。RawImage通常用于需要直接显示纹理、视频帧或动态渲染结果的情况。

#### UIGroup UIPanel：

UIGroup的概念通常用于复杂的UI系统中，以提高UI的模块化、可重用性和可维护性。

（1）UI层级管理：UIGroup可以用于管理UI的层级关系，确保不同UI元素的正确显示顺序和重叠关系。（2）UI元素布局：UIGroup可以用于管理UI元素的布局和位置。（3）UIGroup可以用于管理一组相关的UI元素的交互行为。（4）UI元素状态切换：UIGroup可以用于管理UI元素的状态切换。

#### unity中UI怎么屏幕自适应，原理是什么？

UGUI的屏幕自适应，是通过Canvas Scaler来做的，根据屏幕的分辨率，计算出canvas的大小，同时计算ScaleXY,通过Size + Scale来控制Canvas的变换，UI作为canvas的子物体，也会跟随着一起变化；为了保证UI的位置，需要在设计UI的时候，对角落，边缘的UI做特殊的处理，利用锚点来保证UI与边缘或角落的距离，锚点的概念就不多说了，一句话：锚点的向量值就是锚点与自己轴心的距离。

#### 锚点和中心点的区别：

锚点用于控制游戏对象在屏幕上的位置和大小，中心点用于控制游戏对象的旋转和缩放。

#### 源码解析：
根据Unity2017的UGUI 内核源码的文件夹结构图，可分成了三块，输入事件，动画，核心渲染。

动画：
动画部分相对比较简单，用了tween补间动画的形式，对颜色，位置，大小做了渐进的操作。tween的原理是在启动一个协程，在协程里对元素的属性渐进式的修改，除了修改属性数值，tween还有多种曲线可以选择，比如内番曲线，外翻曲线等，一个数值从起点到终点的过程可以由曲线来控制。

输入事件：
UGUI 把输入事件模块有四部分，事件数据模块，输入事件捕获模块，射线碰撞检测模块，事件逻辑处理及回调模块。
（1）事件数据模块，主要作用为在各种事件发生时，为事件逻辑做好数据工作。
（2）输入事件捕获模块，进行输入监测。
（3）射线碰撞检测模块，主要工作是从摄像机的屏幕位置上，做射线碰撞检测并获取碰撞结果，把结果返回给事件处理逻辑类。射线碰撞检测模块主要为3个类，分别为2D射线碰撞检测，3D射线碰撞检测，GraphicRaycaster图形射线碰撞测试。
（4）事件主逻辑处理模块，主要的逻辑都集中在 EventSystem 类中，EventSystem 是事件处理模块中唯一继承 MonoBehavior 并且有在 Update 帧循环中做轮询的。也就是说，所有UI事件的发生都是通过 EventSystem 轮询监测到的并且实施的。


### 1. 怎么设计一个UI框架？
思考下面这些问题
1. 需要提供哪些方法
2. UI层级怎么处理
3. 如果多个界面同时打开需要怎么处理
4. 导步怎么处理
5. 如果界面有动画怎么处理
6. 同一个界面多次打开怎么处理
7. 不同的UI怎么用同样的方式打开



### 2. UI相关资源的存放规则
1. 大的背景图片,单独管理,不打图集,或者一个图片一个个图集。
2. 公共图集使用,控制公共图集的个数,公共图集的添加要慎重。
3. 不是所有的小图都要使用图集,比如:物品图标
3. 公共Prefab放和公共Prefab文件夹,不与功能Prefab放一起记。
4. 同一功能的Prefab放入一个文件夹,即使功能Prefab只有一个也放入单独文件夹。


### 3. UI中贴图的处理
1. 划分私有图集、公共图集
2. 小图采用九宫格、纯色图片、减少半透明图片
3. 大的的背景图片尽量采用高复用性
4. 一定在项目初就要和美术沟通好图片的规则和规范,避免美术为了设计好看而大量使用半透明和渐变图素,重而导致图集过大以及图集的空间浪费。
5. 图集和背景单图要彻彻底底的分割,别撑大图集

### 4. 有一些公共的Prefab会在多个UI界面里显示,这些公共Prefab怎么处理? 要多个界面里重复实例化吗?
实例化一次，存储prefab的配置文件json，使用时加载用于设置预制体在不同UI界面的状态。
![alt text](image-6.png)


### 5. 垃圾回收机制
标记清除法：标记 -> 清除 -> 压缩

每次运行GC的时候，主要进行下面的操作：（1）GC会检查堆内存上的每个存储变量；（2）对每个变量会检测其引用是否处于激活状态；（3）如果变量的引用不再处于激活状态，则会被标记为可回收；（4）被标记的变量会被移除，其所占有的内存会被回收到堆内存上。

分代策略：
1. 堆(Heap)内存管理区域分为3个:#Gen 0 collections,#Gen 1
collections, #Gen 2 collections.
2. 如果Gen 0 heap内存达到阀值,则触发0代GC,0代GC后Gen 0中幸
存的对象进入Gen1。如果Gen1的内存达到阀值,则进行1代GC, 1
代GC将Gen 0 heap和Gen 1 heap一起进行回收,幸存的对象进入
Gen2。2代GC将Gen 0 heap、Gen 1 heap和Gen 2 heap一起回收。
如果GC跑过了,内存空间依然不够用,那么就抛出了OutOfMemoryException异常。
3. Gen 0和Gen 1比较小,这两个代龄加起来总是保持在16M左右미;
Gen2的大小由应用程序确定,可能达到几G,因此0代和1代GC的成
本非常低,2代GC称为full GC,通常成本很高。

Unity的增量式垃圾回收（Incremental Garbage Collection）主要将​​标记阶段的工作量拆分到多个帧中执行，从而避免单帧卡顿。每帧只从“灰色”队列中取出有限数量的对象进行处理：扫描其内部引用，将新发现的对象标记为灰色并加入队列。这个过程与游戏逻辑交替进行，直到所有可达对象都被标记。

为了实现安全的增量标记，Unity 的垃圾回收器引入了​​写屏障​​机制。在增量标记过程中，如果游戏代码修改了一个已经被标记为“黑色”（表示已处理完成）的对象，使其引用了一个尚未被标记的“白色”对象，写屏障会立即将这个新引用的白色对象标记为灰色，确保它不会被错误回收


Prefab：
------
.prefab文件是一种特殊的资源类型，它记录了预制件（Prefab）的定义和配置。

https://blog.csdn.net/qq_33060405/article/details/143221531

### 1. 主要内容和作用是
1. 对象结构
（1）对象树：.prefab文件记录了预制件中所有游戏对象的层次结构和父子关系。（2）组件信息：每个游戏对象上的组件（如Transform、MeshFilter、Renderer等）及其属性都会被记录在.prefab文件中。
2. 资源引用
（1）资源路径：.prefab文件中包含了对外部资源的引用，例如纹理、材质、音频文件等。这些引用通常是以资源的GUID或相对路径的形式存储的。
（2）动态加载：当预制件被实例化时，Unity会根据这些引用来动态加载所需的资源。
3. 默认值和属性
（1）默认属性值：.prefab文件记录了预制件中各个组件的默认属性值。
（2）可编辑区域：预制件中的某些属性可以被标记为可编辑的，这样在使用预制件时可以修改这些属性而不影响原始的.prefab文件。
4. 版本控制信息
（1）GUID：每个.prefab文件都有一个全局唯一标识符（GUID），Unity使用这个GUID来管理和引用预制件。
（2）依赖关系：.prefab文件可能包含对该.prefab文件所依赖的其他资源的引用信息。

### 2. Prefab的动态加载方式： 

当通过Resources.Load、AssetBundle.LoadAsset读取prefab文件时，引擎会根据组织关系展开prefab，加载关联资源。

GameObject、Component是Unity通过“在C++定义、给C#暴露接口”的形式，封装了某些功能的接口。他们索引了资源，但他们本身不是资源。例如Transform记录了Position、Rotation、Scale信息；MeshRenderer负责从MeshFilter、Material中获得需要的模型、材质数据，告诉Unity该如何渲染。但是，它们并不是“资源”，而是间接引用了资源。

Texture、Mesh、Shader、Material、AnimatorController、AnimationClip等，它们保存了实际的数据，也可以从文件系统中读取、保存到文件。这些是真正意义上的“资源”（Assets）。

### 3. 序列化相关，什么是“GUID”、“Local ID”、“ Instance ID”。
1. File GUID：资源第一次被导入Assets目录内（以下称“工程内”），Unity自动为其分配的一个文件唯一ID，记录在.meta文件中。File GUID设计的初衷，是让引擎的资源管理，可以忽略文件路径的变化。当贴图挪动位置时，引用它的材质球不需要同步地修改。

2. Local ID：同一个文件内，多个UnityEngine.Object（以下称“Object”）的文件内唯一ID。如一个Prefab，可能存在多个子GameObject节点、多个Component。这些Object在Prefab中通过Local ID进行索引。

3. Instance ID：运行时为每个Object生成的Int32索引，本次运行期间唯一。对于Resources下的资源、直接打进包内的场景，Instance ID将在游戏启动时创建；对于AssetBundle内的资源，Instance ID将在加载Object时创建。运行时的比较、加载、操作，都将以Instance ID为Key。只有需要加载时，才使用File GUID + Local ID去查找、加载资源。

模型：
------
模型文件包括网格、材质和纹理。对于动画角色，它们还会包含动画数据。

网格体与材质一起使用，网格描述 GPU 渲染的对象的形状，材质描述其表面的外观。

（1） 网格数据‌：定义3D对象的形状和结构，包含顶点、边、面等几何信息。 

（2） 材质与纹理‌：用于定义物体表面的视觉效果，如颜色、光泽等。 

（3） 动画数据‌（如角色模型）：包含骨骼动画或变形动画信息，用于角色运动控制

（4） 光照贴图‌（Lightmap）：优化光照计算的纹理数据，提升渲染效率。

（5） 碰撞体‌（Collider）：用于物理交互的几何体数据，可独立于网格存在。

（6） 单位转换‌：调整模型与Unity默认单位（米）的对应关系，避免比例失调。 
