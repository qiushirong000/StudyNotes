## Unity原理解析

UGUI：
--------------
锚点（anchors）：
是相对父节点的属性，决定了当屏幕分辨率发生改变的时候，UI的位置和大小如何变化。

中心点（pivot）：
是相对于节点本身的属性，Pivot点的坐标是一个归一化的2D模型坐标系下的坐标，决定了物体如何向两边延伸以及如何旋转。

尺寸变化量（sizeDelta）：
RectTransform的四个角相对于四个锚点的屏幕空间下的距离差。

anchoredPosition：
屏幕空间坐标系下，当前物体的pivot点相对于锚点的pivot点的距离。


Graphic：Graphic作为图像组件的基类,主要实现了网格与图像的生成/刷新方法。

EventSystem: UGUI事件管理系统,通过此系统完成我们所知的UI交互。
管理所有的输入检测模块(InputModule)并帧调用Module的执行(Process)
调动射线捕捉模块(Raycasters),为InputModule提供结果(具体本的触点所穿透的
对象信息)


### 1. 怎么设计一个UI框架？
思考下面这些问题
1. 需要提供哪些方法
2. UI层级怎么处理
3. 如果多个界面同时打开需要怎么处理
4. 导步怎么处理
5. 如果界面有动画怎么处理
6. 同一个界面多次打开怎么处理
7. 不同的UI怎么用同样的方式打开



### 2. UI相关资源的存放规则
1. 大的背景图片,单独管理,不打图集,或者一个图片一个个图集。
2. 公共图集使用,控制公共图集的个数,公共图集的添加要慎重。
3. 不是所有的小图都要使用图集,比如:物品图标
3. 公共Prefab放和公共Prefab文件夹,不与功能Prefab放一起记。
4. 同一功能的Prefab放入一个文件夹,即使功能Prefab只有一个也放入单独文件夹。


### 3. UI中贴图的处理
1. 划分私有图集、公共图集
2. 小图采用九宫格、纯色图片、减少半透明图片
3. 大的的背景图片尽量采用高复用性
4. 一定在项目初就要和美术沟通好图片的规则和规范,避免美术为了设计好看而大量使用半透明和渐变图素,重而导致图集过大以及图集的空间浪费。
5. 图集和背景单图要彻彻底底的分割,别撑大图集

### 4. 有一些公共的Prefab会在多个UI界面里显示,这些公共Prefab怎么处理? 要多个界面里重复实例化吗?
实例化一次，存储prefab的配置文件json，使用时加载用于设置预制体在不同UI界面的状态。
![alt text](image-6.png)


### 5. 垃圾回收机制
标记清除法：标记 -> 清除 -> 压缩

每次运行GC的时候，主要进行下面的操作：（1）GC会检查堆内存上的每个存储变量；（2）对每个变量会检测其引用是否处于激活状态；（3）如果变量的引用不再处于激活状态，则会被标记为可回收；（4）被标记的变量会被移除，其所占有的内存会被回收到堆内存上。

分代策略：
1. 堆(Heap)内存管理区域分为3个:#Gen 0 collections,#Gen 1
collections, #Gen 2 collections.
2. 如果Gen 0 heap内存达到阀值,则触发0代GC,0代GC后Gen 0中幸
存的对象进入Gen1。如果Gen1的内存达到阀值,则进行1代GC, 1
代GC将Gen 0 heap和Gen 1 heap一起进行回收,幸存的对象进入
Gen2。2代GC将Gen 0 heap、Gen 1 heap和Gen 2 heap一起回收。
如果GC跑过了,内存空间依然不够用,那么就抛出了OutOfMemoryException异常。
3. Gen 0和Gen 1比较小,这两个代龄加起来总是保持在16M左右미;
Gen2的大小由应用程序确定,可能达到几G,因此0代和1代GC的成
本非常低,2代GC称为full GC,通常成本很高。

Unity的增量式垃圾回收（Incremental Garbage Collection）主要将​​标记阶段的工作量拆分到多个帧中执行，从而避免单帧卡顿。每帧只从“灰色”队列中取出有限数量的对象进行处理：扫描其内部引用，将新发现的对象标记为灰色并加入队列。这个过程与游戏逻辑交替进行，直到所有可达对象都被标记。

为了实现安全的增量标记，Unity 的垃圾回收器引入了​​写屏障​​机制。在增量标记过程中，如果游戏代码修改了一个已经被标记为“黑色”（表示已处理完成）的对象，使其引用了一个尚未被标记的“白色”对象，写屏障会立即将这个新引用的白色对象标记为灰色，确保它不会被错误回收


Prefab：
------
.prefab文件是一种特殊的资源类型，它记录了预制件（Prefab）的定义和配置。

https://blog.csdn.net/qq_33060405/article/details/143221531

### 1. 主要内容和作用是
1. 对象结构
（1）对象树：.prefab文件记录了预制件中所有游戏对象的层次结构和父子关系。（2）组件信息：每个游戏对象上的组件（如Transform、MeshFilter、Renderer等）及其属性都会被记录在.prefab文件中。
2. 资源引用
（1）资源路径：.prefab文件中包含了对外部资源的引用，例如纹理、材质、音频文件等。这些引用通常是以资源的GUID或相对路径的形式存储的。
（2）动态加载：当预制件被实例化时，Unity会根据这些引用来动态加载所需的资源。
3. 默认值和属性
（1）默认属性值：.prefab文件记录了预制件中各个组件的默认属性值。
（2）可编辑区域：预制件中的某些属性可以被标记为可编辑的，这样在使用预制件时可以修改这些属性而不影响原始的.prefab文件。
4. 版本控制信息
（1）GUID：每个.prefab文件都有一个全局唯一标识符（GUID），Unity使用这个GUID来管理和引用预制件。
（2）依赖关系：.prefab文件可能包含对该.prefab文件所依赖的其他资源的引用信息。

### 2. Prefab的动态加载方式： 

当通过Resources.Load、AssetBundle.LoadAsset读取prefab文件时，引擎会根据组织关系展开prefab，加载关联资源。

GameObject、Component是Unity通过“在C++定义、给C#暴露接口”的形式，封装了某些功能的接口。他们索引了资源，但他们本身不是资源。例如Transform记录了Position、Rotation、Scale信息；MeshRenderer负责从MeshFilter、Material中获得需要的模型、材质数据，告诉Unity该如何渲染。但是，它们并不是“资源”，而是间接引用了资源。

Texture、Mesh、Shader、Material、AnimatorController、AnimationClip等，它们保存了实际的数据，也可以从文件系统中读取、保存到文件。这些是真正意义上的“资源”（Assets）。

### 3. 序列化相关，什么是“GUID”、“Local ID”、“ Instance ID”。
1. File GUID：资源第一次被导入Assets目录内（以下称“工程内”），Unity自动为其分配的一个文件唯一ID，记录在.meta文件中。File GUID设计的初衷，是让引擎的资源管理，可以忽略文件路径的变化。当贴图挪动位置时，引用它的材质球不需要同步地修改。

2. Local ID：同一个文件内，多个UnityEngine.Object（以下称“Object”）的文件内唯一ID。如一个Prefab，可能存在多个子GameObject节点、多个Component。这些Object在Prefab中通过Local ID进行索引。

3. Instance ID：运行时为每个Object生成的Int32索引，本次运行期间唯一。对于Resources下的资源、直接打进包内的场景，Instance ID将在游戏启动时创建；对于AssetBundle内的资源，Instance ID将在加载Object时创建。运行时的比较、加载、操作，都将以Instance ID为Key。只有需要加载时，才使用File GUID + Local ID去查找、加载资源。

模型：
------
模型文件包括网格、材质和纹理。对于动画角色，它们还会包含动画数据。

网格体与材质一起使用，网格描述 GPU 渲染的对象的形状，材质描述其表面的外观。

（1） 网格数据‌：定义3D对象的形状和结构，包含顶点、边、面等几何信息。 

（2） 材质与纹理‌：用于定义物体表面的视觉效果，如颜色、光泽等。 

（3） 动画数据‌（如角色模型）：包含骨骼动画或变形动画信息，用于角色运动控制

（4） 光照贴图‌（Lightmap）：优化光照计算的纹理数据，提升渲染效率。

（5） 碰撞体‌（Collider）：用于物理交互的几何体数据，可独立于网格存在。

（6） 单位转换‌：调整模型与Unity默认单位（米）的对应关系，避免比例失调。 
