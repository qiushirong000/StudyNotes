Lua面试题
============

Lua
-------

### 1. 介绍一下Lua语言

Lua是一种轻量级、高效、可扩展的脚本语言，设计目标是为嵌入式系统提供一个可扩展、小巧、高效、易于学习和使用的脚本语言，同时也可作为通用目的脚本语言使用。

简洁：Lua语言的语法非常简洁，具有类似于C语言的结构化语法。

轻量级：Lua的核心只有数百KB，非常适合移动设备等资源有限的环境中使用。

可扩展：Lua可以通过编写C语言扩展模块来增加新的功能，也可以通过Lua语言本身的元表和协程等特性进行自定义扩展。

高效：Lua语言的执行速度非常快，底层是C语言开发的。

可移植性：Lua语言可以在各种操作系统上运行，包括Windows、Linux、Android等。

开源：Lua语言使用MIT许可证，开放源代码，可以免费使用和分发。

### 2. lua深拷贝和浅拷贝的区别？如何实现深拷贝？

Lua中的浅拷贝（shallow copy）和深拷贝（deep copy）是针对表（table）类型的。浅拷贝是指将一个表的引用赋值给另一个变量，使得两个变量指向同一个表，修改其中任何一个变量所指向的表的值都会影响另一个变量所指向的表的值。深拷贝是指将一个表的所有键值对复制到一个新的表中，使得两个表互不影响。

浅拷贝：使用 = 运算符进行。拷贝对象是string、number、bool基本类型。拷贝的过程就是复制黏贴，修改新拷贝出来的对象，不会影响原先对象的值，两者互不干涉。拷贝对象是table表，拷贝出来的对象和原先对象时同一个对象，占用同一个对象，只是一个人两个名字，类似C#引用地址，指向同一个堆里的数据，两者任意改变都会影响对方。

深拷贝：实现深拷贝的关键在于递归地遍历原始表，将原始表中的键值对复制到新的表中，并对新的表中的每个嵌套的表也进行递归复制，还需复制metetable元表。

### 3. lua中ipairs和pairs的区别？

ipairs用于遍历数组部分（即下标从1开始连续递增的部分），以及具有数值键的表。遍历从第一个元素开始，直到遇到第一个nil或[]元素为止。ipairs会返回两个值：下一个元素的值和下一个元素的下标。

pairs用于遍历表中的所有键值对，包括数组部分和非数组部分。遍历时，pairs会返回两个值：下一个键和对应的值。遍历顺序不确定，元素是根据哈希算法来排序的，可能会随机遍历表中的键值对。

ipairs和pairs在遍历时都不会遍历表中的元方法（metatable）。
。
### 4. 解释下lua中的元表和元方法？

在Lua中，每个值都可以有一个元表（metatable）。元表是一个Lua表，它定义了该值的一些特殊行为，例如运算符重载、索引（index）和新索引（newindex）等操作的实现方式。元表的一个重要用途是实现Lua中的面向对象编程特性。

元表中的键称为元方法（metamethod），它们是一些特殊的函数，用于定义对应操作的行为。元方法的名称是固定的，例如__add、__sub、__index、__newindex等。当Lua执行某些操作时，如果该值具有元表且元表中定义了对应的元方法，Lua会调用元方法来完成该操作，而不是使用默认操作方式。只设置元表是不管用，需要同时设置元表和对应的元方法的代码。

### 5. Lua如何实现面向对象？

Lua中table是非常强大的数据结构，利用table再结合元表metatable，可以方便的在Lua中模拟类，并实现面向对象编程中具有的特性：封装、继承、多态。

封装：利用Lua实现类，可以使用一个表a来表示，该表中包含类的属性和方法。定义构造方法创建实例，定义方式是通过函数传入成员变量，函数中使用表b接收成员变量，再设置表b的元表为表a，返回表b，b就是类的实例。你可以创建一个表，将需要封装的数据和方法作为表的字段，然后使用闭包或者元表来限制对这些字段的访问。

继承：使用元表和元方法来实现继承，将元表设置为父类，在实现lua索引查找机制，要注意构造函数新表和设定元表。

多态：相同方法名子类有不同的处理逻辑，通过重写父类的方法，如果想要保留父类处理逻辑，自定义加入base属性。通过base调用父类方法是不使用“：”，通过“.”然后传入self到父类函数内部。

### 6. table和元表metatable的一些重要知识点有哪些？

 table 是 Lua 的一种数据结构，用于帮助我们创建不同的数据类型，如：数组、字典等；

table 是一个关联型数组，你可以用任意类型的值来作数组的索引，但这个值不能是 nil，所有索引值都需要用 “[“和”]” 括起来；如果是字符串，还可以去掉引号和中括号； 即如果没有[]括起，则认为是字符串索引，Lua table 是不固定大小的，你可根据自己需要进行扩容；

table 的默认初始索引一般以 1 开始，如果不写索引，则索引就会被认为是数字，并按顺序自动从1往后编；

table 的变量只是一个地址引用；

table 不会固定长度大小，有新数据插入时长度会自动增长；

table 里保存数据可以是任何类型，包括function和table；

table所有元素之间，总是用逗号 “，” 隔开。

### 7. Lua和C#交互原理？

Wrap文件：每一个Wrap文件都是对一个C#类的包装。

C# Call Lua交互过程：C#文件先调用Lua的解析器底层的dll库（C语言编写），再由DLL文件执行相应的Lua文件。创建 Lua 虚拟机，并加载 Lua 脚本文件；调用 Lua 函数。

Lua Call C# 交互过程：C# 函数可以通过 Lua 的 C API 将自己注册为一个全局函数，然后在 Lua 中通过函数名来调用。（1）Wrap方式：首先生成C#源文件对应的Wrap文件，Lua文件会调用生成的Wrap文件，再由Wrap文件去调用C#文件。（2）反射方式：当索引系统API、DLL库或者第三方库，如果无法将代码具体实现进行代码生成，可通过反射来获取，执行效率较低。反射是指在运行时动态地获取程序类型信息和访问程序成员的能力。

 C#与Lua交互原理：虚拟栈。交互通过虚拟栈实现，栈的索引分为正数和负数，如果索引是正数，则1表示栈底，如果索引是负数，则-1表示在栈顶。虚拟栈是由 Lua 虚拟机维护的，它是一个包含多个元素的数组，每个元素可以是不同类型的值，如整数、浮点数、字符串、table 等。Lua 提供了一组 C API 函数，可以让 C# 代码访问和操作虚拟栈，从而实现 C# 和 Lua 的数据交换。

C# Call Lua交互原理：C#先将数据放入栈中，然后Lua去栈中获取数据，然后返回数据对应的值到栈顶，再由栈顶返回至C#。C#调用Lua是依靠C作为中间语言，通过C#调用C，C再调用Lua实现的而框架中的tolua.dll等也就是借助LuaInterface封装的C语言动态库。

Lua Call C#交互原理：C#源文件生成Wrap文件、或C#源文件生成C模块，将Wrap文件和C模块注册到Lua的解析器中，最后再由Lua去调用这个模块的函数。Lua调用C#，调用之前需要注册，将函数地址告知Lua。

第三方库：NLua、LuaInterface。

### 8. C#和Lua之间的差异：

（1）类型：Lua是动态类型，弱类型语言【运行时确认】，C#是静态类型，强类型语言。【编译时确认】

（2）语法：C# 的语法比 Lua 更为复杂，需要使用大量的关键字和符号来表示不同的语法结构。Lua 则相对简单，语法结构较为简洁明了。

### 9. 说说lua中的闭包？

闭包=函数+引用环境。子函数可以使用父函数中的局部变量，这种行为可以理解为闭包。upvalue所指向的值，如果在栈中，即仍在作用域内，此upvalue叫做open upvalue。如果upvalue指向的值已经退栈，超出了作用域，则生成一份单独的拷贝upvalue，叫做close upvalue。lua解释器维护了一个open upvalue链表，当需要引用upvalue时，首先遍历此链表，实现upvalue复用；如果没有找到，则在链表中插入此upvalue；当upvalue退出栈时，也会从链表中删除。

闭包的数据隔离：不同实例上的两个不同闭包中的upvalue变量各自独立，实现数据隔离。

闭包的数据共享：两个闭包共享一份变量upvalue，引用的是更外部函数的局部变量（即Upvlaue）,变量是同一个，引用也指向同一个地方，从而实现对共享数据进行访问和修改。

闭包实现迭代器：迭代器只是一个生成器，本身不带循环。我们还需要在循环里面去调用它。while…do循环，每次调用迭代器都会产生一个新的闭包，闭包内部包括了upvalue(t,i,n)，闭包根据上一次的记录，返回下一个元素，实现迭代。for…in循环，只会产生一个闭包函数，后面每次迭代都是使用该闭包函数。内部保存迭代函数、状态常量、控制变量。由于闭包会保持对其创建时所在的环境的引用，因此在迭代器函数内部可以访问和修改 iterator 函数的局部变量 index，而不会被外部环境影响。这样就实现了迭代器的状态与行为的封装。

### 10. 请深入说明Lua的数据结构和内存占用？

Lua 的数据结构是基于标记-垃圾回收（Mark and Sweep）算法的动态类型对象系统，它由以下数据类型组成：nil 空；number 整数（8个字节）；table 表；string 字符；userdata 自定义；function 函数（32位4字节，64位8字节）；bool 布尔（1个字节）；thread线程。

### 11. lua是如何实现热更新的？

Lua 实现热更新的核心思路是将原来的代码和数据分离，将代码部分放在外部文件中，然后在程序运行时动态加载这些文件，从而实现代码的热更新。热更的核心就是替换Package.loaded表中的模块。
  
使用模块加载器：Lua 提供了一个 package 模块，可以用于加载外部的 Lua 模块。可以在代码中使用 require 函数加载外部的模块，从而实现动态加载代码。package.loaded：存储已经被加载的模块，require从package.loader中获得的值仅仅是对那张表（模块）的引用，改变这个值并不会改变require使用的表（模块）。package.preload：保存一些特殊模块的加载器。package.searchers：require查找加载器的表。

使用 Lua 虚拟机：可以使用 Lua 的 C API 直接在 C/C++ 代码中嵌入 Lua 虚拟机，并在程序运行时动态加载外部的 Lua 代码。

### 12. Lua的GC垃圾回收机制算法

Lua借助grey链表，依次利用reallymarkobject对对象进行了颜色标记，之后通过遍历alloc链表，依次利用sweeplist清除需要回收的对象，是增量式的垃圾回收算法，在多帧内完成。

Lua 的内存管理采用自动垃圾回收机制，它会周期性地扫描内存中的对象，标记出不再使用的对象，然后将这些对象的内存空间释放回操作系统。Lua 内存管理的核心是垃圾回收机制，它主要包括以下几个步骤：（1）标记（Marking）：从根对象开始遍历内存中的所有对象，标记所有可以访问到的对象。（2）清除（Sweeping）：遍历内存中的所有对象，将未标记的对象释放回操作系统。（3）压缩（Compacting）：将内存中的对象向一端移动，使得内存空间连续，便于内存分配。Lua 的垃圾回收机制也可以通过一些配置选项进行优化。


### 13. Lua中的GC优化，防止内存泄露

（1）Xlua可以打标签[GCOptimize] ，C#复杂类型struct类型是引用传递到Lua，对满足条件的struct，在Lua一侧做到无GC。

（2）游戏逻辑层：实体管理器如果是本身持有了实体，那么就不应该有create/remove接口。所有实体资源,主要是目前的玩家逻辑数据, 必须直接绑定在角色上，确保角色的销毁会引发实体资源的销毁；全局资源性的数据，可以考虑放在weak table中。

（3）可以对lua中的模块进行分代, 不同的数据使用不同的保存,封装和清除策略,保证在最大效率的情况下准确的完成垃圾收集。

（4）Collectgarbage方法就是开放给Lua开发人员的API，用于监听Lua的内存使用情况(collectgarbage(“count”))，或者需要定期调用collectgarbage(“collect”)，或者collectgarbage(“step”)）进行显式回收。

### 14. Lua如何调用C#

（1）执行字符串；使用LuaEnv.DoString(“文件名称”)，专门用来做执行lua的主入口Main.lua。

（2）如果Resource文件下的Lua文件，使用Lua的Require函数即可。在Main.lua文件里Require其它lua文件。

（3）如果Lua文件是下载的，使用自定义Loader可满足。

### 15. 资源如何打包？依赖项列表如何生成？

查找指定文件ABResource里的资源文件：（1）Directory.GetFile(资源路径);（2）新建AssetBundleBuild对象；（3）获取资源名称，并赋值对应AB名称；（4）获取各个资源的依赖项：通过UnityEditor.AssetDataBase类获取各个资源的依赖项。

使用Unity自带的BuildPipeline进行构建AB包：（1）BuildPipeLine.BuildAssetBundles(输出AB包路径)；（2）File.WriteAllLines(将依赖项写入文件里)。

### 16. 如何解析版本文件？如何加载AB包资源？具体流程是怎么样的？

解析版本文件列表：（1）File.ReadAllLines(读取文件列表资源路径URL)；（2）获取资源名称，获取AB包名称，获取依赖项，字典容器存储；（3）获取Lua文件。

加载资源：（1）异步加载资源AB包，AssetBundleRequest请求，AssetBundle. LoadFromFileAsync。（2）先检查依赖项，再异步加载AB包依赖项；（3）加载成功后都有对应的回调方法，将资源作为参数传入。


### 17. 热更新方案有哪些？以及具体热更流程

（1）整包：存放在上SteamingAssets里。策略：完整更新资源放在包里。优点：首次更新少。缺点：安装包下载时间长，首次安装久。国内游戏大部分是使用整包策略。

（2）分包：策略：少部分资源放在包里，大部分更新资源存放在更新资源器中；优点：安装包小，安装时间短，下载快；缺点：首次更新下载解压缩包时间长。海外游戏大部分是使用分包策略，平台规定。

【从资源服务器】下载单个文件或多个文件：NetWorking.UnityWebRequest获取URL , HTTP GET , 连接资源服务器。获取到downloadHander的文件数据Data，完成后会回调方法，将文件Data作为参数传出。

### 18.  Resource.UnloadAsset前提条件？（错误分类，应该放在Unity中）

Resources.UnloadUnusedAssets可卸载Resources.Load的资源，也可以卸载AssetBundle.Load加载的资源，只是前提是其对应的AssetBundle已经调用Unload(false)，且并没有被引用。

### 19.  __index和__newindex元方法的区别？

访问不存在的数据，由__index提供最终结果；__index元方法可以是一个函数，Lua语言就会以【表】和【不存在键】为参数调用该函数；__index元方法也可以是一个表，Lua语言就访问这个元表。

__newindex用于表的更新，__index用于表的查询；对表中不存在的值进行赋值的时候，解释器会查找__newindex；__newindex元方法如果是一个表，Lua语言就对这个元表的字段进行赋值。

### 20. xLua的热修复原理

xLua热修复是指在游戏运行时修复Lua脚本中的错误、逻辑问题，来解决游戏Bug。

第一步：通过对C#的类与函数设置Hotfix标签。来标识需要支持热更的类和函数。

第二步：生成函数连接器来连接LUA脚本与C#函数。涉及Lua与C#的交互。

第三步：在C#脚本编译结束后，使用Mono提供的一套C#的API函数，对已经编译过的.Net体系生成的DLL文件进行修改。IL注入。

第四步：通过LUA修改C#带有标签的类中静态变量，把代码执行路径修改到LUA中。

### 21. Lua的sort排序用的是什么排序方法？

table.sort的内部使用的是快排，并对其做了三点优化。

（1）对于迭代函数中分割数组长度小于等于3的，通过比较大小排序，减少递归调用深度。

（2）每次通过基准分割数组后，对长度较小的一半进行递归调用，另一半则继续通过While继续分割处理，目的应该也是减少递归调用的深度。

（3）使用数组的开头、中间、结尾中间大的元素作为基准，减少特殊情况时快排的次数。

注意：sort排序的表必须是从1-n连续的，不能有nil。

### 22. Lua怎么设置一个变量为只读？

修改__newindex，当其修改时直接return。