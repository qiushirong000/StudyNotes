计算机基础知识面试题
============
C#
-------

### 1. 重载和重写的区别

封装、继承、多态所处位置不同，重载在同类中，重写在父子类中。

定义方式不同，重载方法名相同参数列表不同，重写方法名和参数列表都相同。

调用方式不同，重载使用相同对象以不同参数调用，重写用不同对象以相同参数调用。

多态时机不同，重载时编译时多态，重写是运行时多态。


### 2. 面向对象的三大特点

继承： 提高代码重用度，增强软件可维护性的重要手段，符合开闭原则。继承最主要的作用就是把子类的公共属性集合起来，便与共同管理，使用起来也更加方便。你既然使用了继承，那代表着你认同子类都有一些共同的特性，所以你把这些共同的特性提取出来设置为父类。继承的传递性：传递机制 a▶b; b▶c; c具有a的特性。继承的单根性：在C#中一个类只能继承一个类，不能有多个父类。

封装： 封装是将数据和行为相结合，通过行为约束代码修改数据的程度，增强数据的安全性，属性是C#封装实现的最好体现。就是将一些复杂的逻辑经过包装之后给别人使用就很方便，别人不需要了解里面是如何实现的，只要传入所需要的参数就可以得到想要的结果。封装的意义在于保护或者防止代码（数据）被我们无意中破坏。

多态性： 多态性是指同名的方法在不同环境下，自适应的反应出不同得表现，是方法动态展示的重要手段。多态就是一个对象多种状态，子类对象可以赋值给父类型的变量。

### 3.

值类型：包含了所有简单类型（整数、浮点、bool、char）、struct、enum；继承自System.ValueType。引用类型包含了string，object，class，interface，delegate，array 继承自System.Object。

值类型存储在内存栈中，引用类型数据存储在内存堆中，而内存单元中存放的是堆中存放的地址。值类型存取快，引用类型存取慢。值类型表示实际数据，引用类型表示指向存储在内存堆中的数据的指针和引用。栈的内存是自动释放的，堆内存是.NET 中会由 GC 来自动释放。值类型继承自 System.ValueType,引用类型继承自 System.Object。值类型直接存放实际的数据，⽽引⽤类型ᰁ存放的则是数据的地址，即对象的引⽤。值类型变量直接把变量的值保存在堆栈中，引⽤类型的变量把实际数据的地址保存在堆栈中。


### 4. 请简述private，public，protected，internal的区别

public：对任何类和成员都公开，无限制访问

private：仅对该类公开

protected：对该类和其派生类公开

internal：只能在包含该类的程序集中访问该类

protected internal：protected + internal

### 5. C#中所有引用类型的基类是什么

引用类型的基类是System.Object，值类型的基类是 System.ValueType。同时，值类型也隐式继承自System.Object。

### 6. 请简述ArrayList和List的主要区别

ArrayList不带泛型，数据类型丢失，List带泛型，数据类型不丢失。

ArrayList需要装箱拆箱，List不需要。

ArrayList存在不安全类型（ArrayList会把所有插⼊其中的数据都当做Object来处理）装箱拆箱的操作（费时），IList是接⼝，ArrayList是⼀个实现了该接⼝的类，可以被实例化。

List类是ArrayList类的泛型等效类。它的大部分用法都与ArrayList相似，因为List类也继承了IList接口。最关键的区别在于，在声明List集合时，我们同时需要为其声明List集合内数据的对象类型。


### 7. 请简述GC（垃圾回收）产生的原因和原理，并描述如何避免？

GC为了避免内存溢出而产生的回收机制。

原理：标记并清除法+分代回收：标记并清除的方式会选择一部分引用类型的对象作为根对象，然后去递归标记对象以及对象的引用类型成员，最后所有已标记的引用类型对象会存活下来，而未被标记的引用类型对象会被回收。.NET中将引用类型的对象分为三类，分别是第0代，第1代与第2代。NET垃圾回收机制中第0代和第1代的处理频率比较高，第2代比较低。分代依据的目的是，尽量增加每次执行垃圾回收处理时，可回收的对象数量，并减少处理所需的时间。

避免方法： （1）减少new产生对象的次数 （2）使用公用的对象（静态成员） （3）将String换为 StringBuilder。

### 8. 请描述Interface与抽象类之间的不同

接口不是类，不能实例化；抽象类可以间接实例化。

接口是完全抽象，抽象类为部分抽象。

接口可以多继承，抽象类是单继承。

### 9. 请简述关键字Sealed用在类声明和函数声明时的作用

类声明时可防止其他类继承此类，在方法中声明则可防止派生类重写此方法。

### 10. 什么是特性，什么是反射，反射的实现原理

特性：为程序信息额外添加声明信息的一种方式。

反射：反射是一种能力，运行时获取程序集中的元信息。

在加载程序运行时，动态获取和加载程序集，并且可以获取到程序集的信息。反射即在运行期动态获取类、对象、方法、对象数据等的一种重要手段，主要使用的类库：System.Reflection。

核心类：Assembly描述了程序集。Type描述了类的类型。ConstructorInfo描述了构造函数。MethodInfo描述了所有的方法。FieldInfo描述了类的字段。PropertyInfo描述类的属性。

通过以上核心类可在运行时动态获取程序集中的类，并执行类构造产生类对象Activator.CreateInstance(t)，动态获取对象的字段或属性值，动态执行类方法和实例方法等。

### 11. Net与 Mono 的关系？

.Net是一个语言平台，Mono为.Net提供集成开发环境，集成并实现了.NET的编译器、CLR 和基础类库，使得.Net既可以运行在windows也可以运行于Linux，Unix，Mac OS等。

### 12. 在类的构造函数前加上static会报什么错?为什么?

构造函数格式为public+类名，如果加上static会报错。在C#中一个类只能拥有一个静态构造函数，也叫做静态构造器（static constructor）。静态构造函数是一个特殊的构造函数，它在类被加载时自动调用，而且只被调用一次。静态构造函数通常用于初始化静态变量或执行其他一次性的初始化操作。静态构造函数不能指定任何访问修饰符，不能被显式地调用。运行库创建类实例或者首次访问静态成员之前，运行库调用静态构造函数； 静态构造函数执行先于任何实例级别的构造函数； 显然也就无法使用this和 base 来调用构造函数。 一个类只能有一个静态构造函数，如果有静态变量，系统也会自动生成静态构造函数。

在类的构造函数前加上 static 关键字是不合法的，因为构造函数是用于创建实例的，而静态成员属于类本身，不与实例相关。


### 13. C# String类型比 stringBuilder 类型的优势是什么?

如果是处理字符串的话，用string中的方法每次都需要创建一个新的字符串对象并且分配新的内存地址，而 stringBuilder 是在原来的内存里对字符串进行修改，所以在字符串处理方面还是建议用stringBuilder这样比较节约内存。但是string类的方法和功能仍然还是比 stringBuilder 类要强。

String类由于具有不可变性（即对一个string对象进行任何更改时，其实都是创建另外一个string类的对象），所以当需要频繁的对一个string类对象进行更改的时候，建议使用StringBuilder类，StringBuilder类的原理是首先在内存中开辟一定大小的内存空间，当对此 StringBuilder 类对象进行更改时，如果内存空间大小不够，会对此内存空间进行扩充，而不是重新创建一个对象，不会造成过多的内存浪费，其实本质上并没有很大区别，都是用来存储和操作字符串的，唯一的区别就在于性能上。String主要用于公共 API，通用性好、用途广泛、读取性能高、占用内存小。StringBuilder主要用于拼接 String，修改性能好。不过现在的编译器已经把String的 + 操作优化成 StringBuilder 了， 所以一般用String 就可以了。String是不可变的，所以天然线程同步。StringBuilder可变，非线程同步。

### 14. C#函数 Func(string a, string b)用 Lambda 表达式怎么写?

(a,b) => {};

### 15. C#中有哪些常用的容器类，各有什么特点。

List， HashTable，Dictionary， Stack，Queue。

Stack栈：先进后出，入栈和出栈，底层泛型数组实现，入栈动态扩容2倍。

Queue队列：先进先出，入队和出队，底层泛型数组实现，表头表尾指针。

Array数组：一种固定大小的数据结构，需要声明长度，不安全。

ArrayList数组列表：一种动态大小的数据结构，不安全，即元素的类型只能在运行时检查。实现了IList接口（表示可按照索引进行访问的非泛型集合对象），Object数组实现。

List列表：底层实现是泛型数组，特性，动态扩容，泛型安全。将泛型数据（对值类型来说就是数据本身，对引用类型来说就是引用）存储在一个泛型数组中，添加元素时若超过当前泛型数组容量，则以2倍扩容，进而实现List大小动态可变，存储不同类型的数据。

LinkList链表：1）数组和List、ArrayList集合都有一个重大的缺陷，就是从数组的中间位置删除或插入一个元素需要付出很大的代价，其原因是数组中处于被删除元素之后的所有元素都要向数组的前端移动。 2）LinkedList（底层是由链表实现的）基于链表的数据结构，很好的解决了数组删除插入效率低的问题，且不用动态的扩充数组的长度。 3）LinkedList的优点：插入、删除元素效率比较高；缺点：访问效率比较低。

HashTable哈希表（散列表）概念：不定长的二进制数据通过哈希函数映射到一个较短的二进制数据集，即Key通过HashFunction函数获得HashCode 装填因子：α=n/m=0.72，存储的数据N和空间大小M然后通过哈希桶算法，HashCode分段，每一段都是一个桶结构，一般是HashCode直接取余。桶结构会加剧冲突，解决冲突使用拉链法，将产生冲突的元素建立一个单链表，并将头指针地址存储至Hash表对应桶的位置。这样定位到Hash表桶的位置后可通过遍历单链表的形式来查找元素。1、Key—Value形式存取，无序，类型Object，需要类型转换。2、Hashtable查询速度快，而添加速度相对慢3、Hashtable中的数据实际存储在内部的一个数据桶里（bucket结构体数组），容量固定，根据数组索引获取值。

性能排序：

插入性能： LinkedList > Dictionary > HashTable > List

遍历性能：List > LinkedList > Dictionary > HashTable

删除性能： Dictionary > LinkedList > HashTable > List


### 16. C#中常规容器和泛型容器有什么区别，哪种效率高？

不带泛型的容器需要装箱和拆箱操作速度慢。所以泛型容器效率更高，数据类型更安全。

### 17. 有哪些常见的数值类？

简单值类型：包括 整数类型、实数类型、字符类型、布尔类型。

复合值类型：包括 结构类型、枚举类型。

### 18. C#中委托和接口有什么区别？各用在什么场合？

委托（Delegate）和接口（Interface）都是用于实现多态性的机制。委托是一种类型安全的函数指针，它允许将方法作为参数传递给其他方法或存储在变量中，并在需要时调用它。C#中的委托是约束方法集合的一个类，可以便捷的使用委托对这个方法集合进行操作。

接口（interface）是约束类应该具备的功能集合，约束了类应该具备的功能，使类从千变万化的具体逻辑中解脱出来，便于类的管理和扩展，同时又合理解决了类的单继承问题。

在以下情况中使用接口：1.无法使用继承的场合 2.完全抽象的场合 3.多人协作的场合。
在以下情况中使用委托：用于实现回调、事件处理和异步编程等场景。

### 19. C#中unsafe关键字是用来做什么的？什么场合下使用？

unsafe关键字用于标记包含不安全代码的代码块，允许使用指针来直接访问内存，从而提高性能和灵活性。使用unsafe关键字可以直接访问内存中的数据，而不需要进行安全检查，因此需要特别小心使用。unsafe关键字通常用于以下场合：1）与非托管代码的交互：当需要与非托管代码进行交互时，例如调用C或C++编写的库函数，就需要使用unsafe关键字来访问非托管代码的内存。2）高性能计算：在某些高性能计算场景中，使用指针可以提高程序的性能，例如图像处理、数值计算等。

非托管代码是指在操作系统原生环境中执行的代码。

托管代码是基于公共语言运行库的语言编译器开发的代码。


### 20. C#中ref和out关键字有什么区别？

ref和out关键字都用于传递方法参数的引用，ref和out参数的效果一样，都是通过关键字找到定义在主函数里面的变量的内存地址。不同点是ref引用的变量必须在调用方法之前进行初始化，out 参数必须在函数里进行初始化赋值。ref参数是引用，out参数为输出参数，out关键字通常用于返回多个值的场景。

### 21. For，foreach，Enumerator.MoveNext的使用，与内存消耗情况

for循环可以通过索引依次进行遍历，foreach和Enumerator.MoveNext通过迭代的方式进行遍历。内存消耗上本质上并没有太大的区别，foreach和Enumerator.MoveNext性能开销更大些。 但是在Unity中的Update中，一般不推荐使用foreach因为会遗留内存垃圾。

### 22. 函数中多次使用string的+=处理，会产生大量内存垃圾（垃圾碎片），有什么好的方法可以解决。

函数中多次使用string的+=处理，会产生大量内存垃圾（垃圾碎片），有什么好的方法可以解决。

### 23. 当需要频繁创建使用某个对象时，有什么好的程序设计方案来节省内存？

设计单例模式进行创建对象或者使用对象池

### 24. JIT和AOT区别

Just-In-Time -实时编译：执行慢，安装快，占空间小一点。

Ahead-Of-Time -预先编译：执行快，安装慢，占内存和外存大。

### 25. Foreach循环迭代时，若把其中的某个元素删除，程序报错，怎么找到那个元素？以及具体怎么处理这种情况？(注：Try…Catch捕捉异常，发送信息不可行)

foreach不能进行元素的删除，因为迭代器会锁定迭代的集合。
  
解决方法：记录找到索引或者key值，迭代结束后再进行删除。


### 26. 26. GameObject a=new GameObject() GameObject b=a 实例化出来了A，将A赋给B，现在将B删除，问A还存在吗？

存在，b删除只是将它在栈中的内存删除，而A对象本身是在堆中，所以A还存在。如果要完全销毁这个对象，需要将所有对它的引用都删除

### 27.  C#中委托和事件的区别

委托:（1）委托是使用delegate关键字声明的。（2）委托是一个函数指针数组，它在运行时保存一个或多个方法的引用。（3）委托是独立的，不依赖于事件。（4）委托包括Combine()和Remove()方法，用于将方法添加到调用列表中。（5）委托可以作为方法参数传递。（6）=运算符用于分配单个方法，而+=运算符用于将多个方法分配给一个委托。

事件：（1）事件是使用event关键字声明的。（2）事件是一种依赖于委托的通知机制。（3）事件依赖于委托，没有委托就无法创建事件是委托实例的包装，用于防止委托的用户重置委托及其调用列表，并且只允许在调用列表中添加或移除目标。（4）EventInfo类检查事件，并挂接包含AddEventHandler()和RemoveEventHandler()方法的事件处理程序，以分别向调用列表添加和移除方。（5）事件被引发，但不能作为方法参数传递。（6）=运算符不能用于事件，只有+=和-=运算符可以用于添加或移除事件处理程序的事件。这些方法在内部调用AddEventHandler和RemoveEventHandler。

### 28. 结构体和类有何区别?

（默认访问权限好像都是internal，成员都是private）

存储方式：结构体是值类型，类是引用类型。

内存分配：结构体通常分配在栈上，而类通常分配在堆上。

继承和多态：类支持继承和多态，而结构体不支持。

默认构造函数：类有默认构造函数，而结构体没有。

使用场景：结构体适合用于表示简单的值类型数据，而类适合用于表示更复杂的对象。

### 29. C#的委托是什么?有何用处?

委托类似于一种安全的指针引用，在使用它时是当做类来看待而不是一个方法，相当于对一组方法的列表的引用。用处：使用委托使程序员可以将方法引用封装在委托对象内。然后可以将该委托对象传递给可调用所引用方法的代码，而不必在编译时知道将调用哪个方法。与C或C++中的函数指针不同，委托是面向对象，而且是类型安全的。

### 30.  foreach迭代器遍历和for循环遍历的区别

foreach迭代器遍历是基于IEnumerator接口实现的，它通过调用集合类型的GetEnumerator()方法获取一个枚举器（enumerator）对象，然后使用MoveNext()方法将枚举器移动到集合的下一个元素，并返回bool类型的值表示是否成功移动。

for循环遍历则是通过指定循环变量的初始值、终止条件和变化方式来实现的。

### 31. unity中for循环使用lambda表达式的闭包问题。

闭包：闭包就是能够读取其他函数内部变量的函数。闭包可以理解成“定义在一个函数内部的函数”。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。闭包是指一个函数内部引用了外部变量，并将这个函数作为返回值或传递给其他函数时，这个函数会持有对外部变量的引用，导致外部变量的生命周期延长，可能会导致内存泄漏或其他问题。

为了避免闭包引起的问题，可以将外部变量复制到Lambda表达式内部的局部变量中。

### 32. C#和C++的区别?

面向对象程度不同：C++是一种多范式编程语言，支持面向对象、泛型、过程化等多种编程范式，旨在提供高性能和低级别的控制。而C#则是一种面向对象的编程语言，它的所有构造都是对象，旨在提供更高的开发效率和更好的开发体验。

内存管理方式不同：C++要自己管理内存分配和释放，而C#用垃圾回收器自动管理内存。

跨平台能力不同：C++可以编译成可以在不同操作系统上运行的本地代码，但需要编写不同平台的代码，而C#可以使用.NET Framework或.NET Core在不同平台上运行。

编译方式不同：C++是静态编译语言，代码在编译时被编译成本地机器指令，而C#是动态编译语言，在运行时被编译成中间语言，然后由CLR中的JIT编译器编译成本地机器代码。

异常处理方式不同：C++使用try-catch处理异常，而C#使用异常处理器捕获和处理异常。

语法特性不同：C++支持指针、引用、多重继承等特性，C#支持属性、委托、事件等特性。

具体对比：

（1）继承：C++支持多继承，C#类只能继承一个基类中的实现但可以实现多个接口。

（2）数组：声明 C# 数组和声明 C++ 数组的语法不同。在 C# 中，“[]”标记出现在数组类型的后面。

（3）数据类型：在C++中bool类可以与整型转换，但C#中bool 类型和其他类型（特别是 int）之间没有转换。long 类型：在 C# 中，long 数据类型为 64 位，而在 C++ 中为 32 位。

（4）struct 类型：在C#中，类和结构在语义上不同。struct是值类型，而class是引用类型。

（5）switch：与 C++ 中的 switch 不同，C# 不支持从一个 case 贯穿到另一个 case 标签。

（6）delegate 类型：委托与 C++ 中的函数指针基本相似，但前者具有类型安全，是安全的。

（7）从派生类调用重写基类成员。base

（8）使用 new 修饰符显式隐藏继承成员。

（9）重写方法需要父类方法中用virtual声名，子类方法用override 关键字。

（10）预处理器指令用于条件编译。C# 中不使用头文件。 C# 预处理器指令

（11）异常处理：C#中引入了 finally 语句，这是C++没有的。

（12）运算符：C# 支持其他运算符，如is和typeof。它还引入某些逻辑运算符的不同功能。

（13）static 的使用，static方法只能由类名调用，改变static变量。

（14）在构造基类上替代 C++ 初始化列表的方法。

（15）Main 方法和 C++ 及Java中的 main 函数的声明方式不同，Main而不能用main

（16）方法参数：C# 支持 ref 和 out 参数，这两个参数取代指针通过引用传递参数。

（17）在 C# 中只能在unsafe不安全模式下才使用指针。

（18）在 C# 中以不同的方式执行重载运算符。

（19）字符串：C# 字符串不同于 C++ 字符串。

（20）foreach:C#從VB中引入了foreach关键字使得以循环访问数组和集合。

（21）C#没有全局方法和全局变量：方法和变量须包含在类型声明（如class或struct）
中。

（22）C# 中没有头文件和 #include 指令：using 指令用于引用其他未完全限定类型名的命名空间中的类型。

（23）C# 中的局部变量在初始化前不能使用。

（24）析构函数：C#不能控制析构函数的调用时间，原因是析构函数由垃圾回收器自动调用。

（25）构造函数：与 C++ 类似，如果在 C# 中没有提供类构造函数，则为您自动生成默认构造函数。该默认构造函数将所有字段初始化为它们的默认值。

（26）在C#中，方法参数不能有默认值。如果要获得同样的效果，需使用方法重载。


### 33. C#提供了指针的支持吗？

C#提供了对指针的支持，但使用指针需要在代码中显式声明unsafe代码块，使用指针需要使用&运算符来获取变量的地址，使用*运算符来解引用指针。C#中的指针类型是受控的，只能指向特定类型的数据，而不能指向任意地址。提高程序的安全性，也限制了灵活性。

### 34. Mock和Stub有何区别?

Mock与Stub的区别：Mock:关注行为验证。细粒度的测试，即代码的逻辑，多数情况下用于单元测试。Stub：关注状态验证。粗粒度的测试，在某个依赖系统不存在或者还没实现或者难以测试的情况下使用，例如访问文件系统，数据库连接，远程协议等。

### 35. 为什么dynamic font 在unicode环境下优于static font（字符串编码）

支持更广泛的字符集：Unicode字符集包含了世界上大多数语言的字符，而static font通常只支持特定的字符集，如ASCII、ISO-8859等。

动态适应文本的大小和样式：dynamic font可以根据文本的大小和样式来动态生成字形。而static font在生成字形时需要预先指定字号和样式，无法进行动态适应。

### 36. string、stringBuilder、stringBuffer的区别

string：不变性，字符序列不可变，对原管理中实例对象赋值，会重新开一个新的实例对象赋值，新开的实例对象会等待被GC。string拼接要重新开辟空间，因为string原值不会改变，导致GC频繁，性能消耗大。Java中(String类中有一个char数组，并且这个char数组是被final修饰的。因为数组一旦创建长度不可变。并且被final修饰的引用一旦指向某个对象之后，不可在指向其它对象，所以String是不可变的。)

StringBuilder：是字符串可变对象，可通过自带的StringBuffer.方法来改变并生成想要的字符串。对原实例对象做拼接的实例，不会生成新的实例对象。拼接使用

StringBuilder和StringBuffer，只开辟一个内存空间，这是性能优化的点。

StringBuffer：是字符串可变对象，基本和StringBuilder相同。 唯一的区别是
StringBuffer是线程安全，相关方法前带synchronized关键字，一般用于多线程 StringBuilder是非线程安全，所以性能略好，一般用于单线程。三者性能比较 StringBuilder>StringBuffer>String。

### 37. 字典Dictionary的内部实现原理

泛型集合命名空间using System.Collections.Generic; 任何键都必须是唯一。该类最大优点就是它查找元素的时间复杂度接近O(1)，实际项目中常被用来做一些数据的本地缓存。

哈希算法：将不定长度的二进制数据集给映射到一个较短的二进制长度数据集一个Key通过HashFunc得到HashCode。

Hash桶算法：对HashCode进行分段显示，常用方法是对HashCode直接取余。

解决碰撞冲突算法（拉链法）：分段会导致key对应的桶会相同，拉链法的思想就像对冲突的元素，建立一个单链表，头指针存储到对应的哈希桶位置。反之就是通过确定hash桶位置后，遍历单链表，获取对应的value。

### 38. 泛型是什么？

多个代码对【不同数据类型】执行【相同指令】的情况。泛型：多个类型共享一组代码，泛型允许类型参数化，泛型类型是类型的模板。5种泛型：类、结构、接口、委托、方法类型占位符T来表示泛型。泛型类不是实际的类，而是类的模板。从泛型类型创建实例步骤：声明泛型类型，通过提供【真实类型】创建构造函数类型，从构造类型创建实例类。

性能：泛型不会强行对值类型进行装箱和拆箱，或对引用类型进行向下强制类型转换，所以性能得到提高。

安全：通过知道使用泛型定义的变量的类型限制，编译器可以在一定程度上验证类型假设，所以泛型提高了程序的类型安全。

### 39. Mathf.Round和Mathf.Clamp和Mathf.Lerp含义？

Mathf.Round：四舍五入。Mathf.Clamp：左右限值。Mathf.Lerp：插值。

### 40. 能用foreach遍历访问的对象需要实现______接⼝或声明_________⽅法的类型（C#遍历）

IEnumerable；GetEnumerator。

### 41. 概述c#中代理和事件？

代理就是⽤来定义指向⽅法的引⽤。 C＃事件本质就是对消息的封装，⽤作对象之间的通信；发送⽅叫事件发送器，接收⽅叫事件接收器；

### 42. 哈希表与字典对比

字典：内部用了Hashtable作为存储结构。如果我们试图找到一个不存在的键，它将返回 / 抛出异常。它比哈希表更快，因为没有装箱和拆箱，尤其是值类型。仅公共静态成员是线程安全的。字典是一种通用类型，这意味着我们可以将其与任何数据类型一起使用（创建时，必须同时指定键和值的数据类型）。Dictionay是Hashtable 的类型安全实现，Keys和Values是强类型的。Dictionary遍历输出的顺序，就是加入的顺序。

哈希表：如果我们尝试查找不存在的键，则返回 null。它比字典慢，因为它需要装箱和拆箱。哈希表中的所有成员都是线程安全的，哈希表不是通用类型，Hashtable 是松散类型的数据结构，我们可以添加任何类型的键和值。HashTable是经过优化的，访问下标的对象先散列过，所以内部是无序散列的。


### 43.  C#中四种访问修饰符是哪些？各有什么区别？

属性修饰符：Serializable：按值将对象封送到远程服务器。STATread：是单线程套间的意思，是⼀种线程模型。MATAThread：是多线程套间的意思，也是⼀种线程模型。

存取修饰符： public：存取不受限制。 private：只有包含该成员的类可以存取。 internal：只有当前⼯程可以存取。 protected：只有包含该成员的类以及派⽣类可以存取。

类修饰符： abstract：抽象类。指示⼀个类只能作为其它类的基 类。sealed：密封类。指示⼀个类不能被继承。密封类不能同时⼜是抽象类，因为抽象总是希望被继承的。

成员修饰符： abstract：指示该⽅法或属性没有实现。sealed：密封⽅法。可以防⽌在派⽣类中对该⽅法的override（᯿载）。不是类的每个成员⽅法都可以作为密封⽅法密封⽅法，必须对基类的虚⽅法进⾏᯿载，提供具体的实现⽅法。所以，在⽅法的声明中，sealed修饰符总是和override修饰符同时使⽤，作用是防止方法在子类中被重写。。delegate：委托。⽤来定义⼀个函数指针。C#中的事件驱动是基于delegate+event的。 const：指定该成员的值只读不允许修改。event：声明⼀个事件。 extern：指示⽅法在外部实现。override：᯿写。对由基类继承成员的新实现。readonly：指示⼀个域只能在声明时以及相同类的内部被赋值。 static：指示⼀个成员属于类型本身，⽽不是属于特定的对象。即在定义后可不经实例化，就可使⽤。 virtual：指示⼀个⽅法或存取器的实现可以在继承类中被覆盖。new：在派⽣类中隐藏指定的基类成员，从⽽实现᯿写的功能。 若要隐藏继承类的成员，请使⽤相同名称 在派⽣类中声明该成员，并⽤new修饰符修饰它。


### 44.  什么是装箱拆箱，怎样减少操作

C#装箱是将值类型转换为引用类型；拆箱是将引用类型转换为值类型。牵扯到装箱和拆箱操作比较多的就是在集合中，例如：ArrayList或者HashTable之类。

### 45. 什么是MVC？

MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范。用一种业务逻辑、数据、界面显示分离的方法，将业务逻辑聚集到一个部件里面，在改进定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。

Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。 通常模型对象负责在数据库中存取数据。

View（视图）是应用程序中处理数据显示的部分。 通常视图是依据模型数据创建的。

Controller（控制器）是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。

### 46. 委托、事件，Action，Func的作用和区别

Delegate是一个函数容器，首先定义函数模板，符合函数模板的函数可通过+=进行添加，容器.Invoke()执行的时候所有容器内的方法都会执行。

事件Event，由于委托有被赋值的风险，event让委托的赋值权限变为private，安全性更强。

Action是委托的简写，最多支持16个参数的模板。

Func在Action的基础上增加了返回值，返回值为最后一个传入的参数，保留最后注册函数的返回值。

### 47. C#中Dictionary哈希冲突可能导致链表的长度不断增加，查找效率低怎么解决？

C# 中的 Dictionary 类会自动在特定条件下将链表转换为平衡二叉树（红黑树），以提高查找、插入和删除操作的效率。这个转换过程发生在链表长度超过一定阈值（默认为8）时。这样，即便哈希冲突较多，Dictionary 仍能保持较高的性能。

### 48. C#的范型约束有哪些类型

在C#中，泛型约束（Generic Constraints）用于对泛型类型参数进行限制，以指定类型参数必须满足的条件或要求。以下是C#中常用的泛型约束：

（1）无托管类型约束。where T : unmanaged 

（2）接口约束。where T : ISomeInterface

（3）构造函数约束。where T : new()

（4）基类约束。where T : SomeBaseClass

（5）值类型约束。where T : struct

（6）引用类型约束。where T : class


### 49. C#什么是托管堆，什么是非托管堆

托管堆：托管堆是由CLR（Common Language Runtime）负责管理的内存区域。在C#中，当我们创建对象时，这些对象会被分配到托管堆上。CLR会自动进行垃圾回收（Garbage Collection），释放不再使用的对象所占用的内存空间，从而确保内存的有效利用。在托管堆上，对象的分配和回收是由CLR自动管理的，开发人员不需要手动管理内存。

非托管堆：非托管堆是在C#程序中直接使用的非托管内存区域。它通常是通过使用一些特定的方法或库来分配和释放内存，而不受CLR的垃圾回收机制的控制。在非托管堆上分配的内存需要手动释放，否则可能会导致内存泄漏和资源不足等问题。非托管堆主要用于与非托管代码（如C++代码）进行交互，或者在特定情况下需要更精确的内存控制的场景。


### 50.  C#委托的实现原理，局部委托是怎么访问到栈上的内存的？

委托对象存储的是方法的引用：它可以访问方法所在的内存位置，包括栈上的内存。当委托被调用时，它会通过代理访问存储在栈上的方法的内存位置，并执行相应的代码。

委托对象的生命周期：委托对象的生命周期可以超出方法的生命周期。即使方法所在的栈帧被销毁，委托仍然可以继续引用该方法，并在需要时进行调用。这是因为委托对象存储的是方法的引用，而不是方法的执行内容。

栈上的内存访问：当委托对象引用的方法是在栈上定义的局部方法时，委托可以访问栈上的内存。这是因为委托对象在创建时会将方法的引用复制到堆上的委托对象实例中，从而使委托对象在方法栈帧被销毁后仍然可以引用方法。


### 51. C#的IL、CTS、CLS、CLR的基础概念

 IL（intermediate language） 中间语言，是经过编译之后可以执行的二进制代码，实现了.net平台的互联互通，后缀名为.exe或.dll。IL可以被解释或编译成特定平台的本机代码执行。

CTS （Common Type System) 公共类型系统。由于 .Net 平台上的不同语言中的数据类型各不相同，比如整数类型在VB.Net中是 Integer ，而C#中时int 。.Net 平台制定了一个公用类型系统（CTS），各个语言编译器把自己语言的类型翻译成 CTS 中的类型。

CLS (Common Language Specification) 公共语言规范。不同语言的语法不同，比如定义一个类A继承自类B，C# 的语法是 Class A : B{} ，而VB.Net 的语法是 Class A Inherits B 。CLS是一组规范和约定，定义了在.NET平台上编写的可互操作的代码的特性和要求。

CLR（Common Language Runtime）是.NET平台的执行引擎，负责加载、执行和管理.NET应用程序。CLR在运行时提供了一系列服务，如垃圾回收、内存管理、安全性、异常处理等。它还负责将IL代码转换为特定平台的机器代码，还提供了一套标准类库。

ILRuntime：是一个基于IL的动态执行引擎，用于在运行时执行IL代码。与CLR不同，ILRuntime不需要将IL代码先编译为原生代码，而是直接解释和执行IL代码。ILRuntime主要用于一些特殊的场景，如热更新、动态代码生成等。支持在运行时修改和执行IL代码。


### 52. 什么是序列化？

序列化是将对象状态转换为可保存或传输的格式的过程，与序列化相对的是反序列化。

### 53. partial关键字的作用
partial 关键字用于拆分一个类、一个结构、一个接口或一个方法的定义到两个或更多的文件中。 每个源文件包含类型或方法定义的一部分，编译应用程序时将把所有部分组合起来。在设计 Framework 时，可以充分利用 partial 这个特性。