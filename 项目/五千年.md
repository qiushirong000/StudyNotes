# 项目框架
--------------

## 一 UI框架

### 面板管理

1. 维护独立UI panel字典，常驻特殊UI，loading；panels字典，需层级管理UI
2. 维护可索引双向队列，解决某些套娃式的窗口使用。首端添加，删除指定索引，移动到首端。
3. UI Data，传递，强制类型转换。
4. UI Base，OnInit() -> 加载panel预制体(Restart) ->资源加载完成时Load(AssetHandle _)  ->  OnLoad() -> OnShow() 。UIPanels调用Hide<T>(string name = "")  -> 调用UIBase的OnHidden() -> m_UICachePool.Release(name, menu) -》DestroyWnd 调用UIBase的Destroy();


### 二 图集
#### 2.1 图集拆分策略

图集拆分策略​​的核心目标是平衡性能（减少Draw Calls）与内存效率（降低内存峰值）。

(1) 划分私有图集、公共图集。公共图集存放多个模块高频复用的资源，而同一功能/界面​​的临时使用纹理合并到同一私有图集。

(2) 公共图集的添加要慎重,控制公共图集的个数,不是所有的小图都要使用图集，比如物品图标（常伴随游戏逻辑动态变化，打在静态图集中，未使用的图标占比大造成内存浪费。优化方案：动态图集，仅对当前屏幕显示的图标实时打包，避免全量加载）。

(3) 背景图单独一个图集，或者不打图集。

(4) 小图采用九宫格、纯色图片、减少半透明图片；大的的背景图片尽量采用高复用性。

#### 2.2 图集的原理是什么
图集（Texture Atlas）是一种将多个小纹理合并为一张大纹理的技术
图集装箱算法：

（1）断头台算法，Guillotine算法会维护一个剩余矩形list(其中的空白矩形称为F)。主要方法是从uv矩形(称为R)中选出一个放置在F左下角，再将右上方的“L”型空间分割为两个F并组织进list（所以不会有任何一个空白块被忽略）。再递归执行，直到R不能装入list中的任何一个F，则再开一个bin。

（2）最大矩形算法(MaxRects)，保证装箱速度的同时，尽量减少大图的尺寸，从而获得较高的空间利用率。
Guillotine的缺点在于不能跨过分割线，为了解决这个问题，Maximal方法提出了新的分割方式，即同时执行水平分割和竖直分割，并保留两次分割中的包含右上矩形的矩形(或叫maximal矩形)，作为F存入剩余空间list。
https://zhuanlan.zhihu.com/p/375451946


#### 2.3 图集为什么能减低内存
图集最终形成的纹理尺寸变大了，但占用内存减少。原因：

（1）减少了小图的冗余开销，如每张纹理需存储的头部信息（压缩格式元数据），合并图集后只需存一份。

（2）压缩格式的效率提升​，大图集包含更多像素相关性，压缩算法（如ETC2、ASTC）可达到更高压缩。GPU对纹理内存有对齐要求(如4KB/64KB对齐)，并后的大纹理可以更高效地利用对齐空间。

（3） 空白区域的优化处理。


## 设备性能

### 最低配置：
iOS：A9处理器、内存2G及以上配置设备（iPhone 6s及以上）

安卓：高通骁龙460/麒麟710及以上、内存4g及以上设备

### 品质分级

UnityEngine.SystemInfo 获取设备信息

 * 先判断芯片，再判断内存：
 * 内存lv5：12G+, lv4：12G+, lv3:8G+, lv2:6G+, lv1:4G+, lv0:4G-
 * 有cpu取 cpu评级 有gpu取gpu,都有取最低



# 负责模块
--------------

## 城建系统
涉及内城建筑数据的管理，Lod切换时模型的加载和卸载，以及建筑上能指令执行，包括升级、征兵、科技、闭城等等。

### 子系统

边角管理 (HomelandCorners)
- 管理家园的边界检测
- 负责视口可见性判断

定位系统 (HomelandLocator)
- 管理相机定位和视角控制
- 处理锚点、焦点和距离计算
- 控制家园的可见性和激活状态

卫兵系统 (HomelandGuards)
- 管理家园内的卫兵单位
- 采用分帧加载机制优化性能
- 处理卫兵的加载、卸载和更新

建筑系统 (HomelandPawns)
- 管理家园内的建筑的加载和卸载
- 处理建筑升级、研究等事件
- 提供点击选择和交互功能

树木系统 (HomelandTrees)
- 管理家园内的树木和装饰物
- 使用实例化渲染优化性能

交互系统 (HomelandTouch)
- 处理用户输入和点击交互
- 管理射线检测和对象选择

### 生命周期

初始化阶段 ->加载阶段->进入阶段->卸载阶段

### 技术亮点

(1) 分帧加载机制：避免单帧加载过多资源

(2) LOD系统：根据距离动态调整细节层次

(3) 实例化渲染：优化大量相同对象的渲染性能

(4) 建筑编辑工具，组装生成，（1）从场景中导出配置到homeland_pawns中，根据场景节点名称，设置homeland_pawn的路径、位置、偏移、缩放等等。（2）游戏运行时内城的建筑节点，也提供了配置保存方法，导入到asset文件中。

### 1. 数据层：

City 里面存放所有的建筑Building Dictionary<int, Building>；

建筑的动态属性如等级，通过接收服务器数据获得；

建筑的静态属性通过策划表配置获取；

利用工厂模式创建建筑实例；

具体的建筑类方法通过继承基类Building实现；

基类Building主要包含初始化Initialize、加载Load、卸载UnLoad、升级
Upgrade、更新状态方法。

### 2. 外观层：
Homeland 控制内城的加载和卸载，是一个单例且序列化的asset文件，添加了定位器、建筑外观HomelandPawns配置、内城装饰等配置的引用，核心方法是Enter入城和Exit出城两个方法，通过监听Lod的变化进行调用，入城时将这些建筑、场地、卫兵、树木进行组装。

HomelandPawns存放了所有建筑的外观配置，Dictionary<Collider, HomelandPawn> clicks = new();建筑外观类被定义为HomelandPawn，包含了模型的碰撞体、资源加载路径、坐标旋转、UI锚点、UI插槽HomelandSlot等等。


### 3. UI层：
根据Building创建操作命令HomelandConsoleCommand集合，绑定对应的Action事件；
HomelandConsolePanel操作面板，建筑被选择时，将HomelandPawn引用传入面板中，创建功能按钮组。
HomelandSlot加载插槽基类，绑定到HomelandPawn上，显示建筑的名称、等级、状态等。

### 4. 亮点:
（1）内存中的各个模块是在加载时组装而成的，可以构建了对应的asset配置文件，可以设置它们的位置，旋转角度、资源路径、UI锚点位置等等。

（2）Lod切换时入城分帧加载各模块，更加平滑，降低了性能峰值。

（3）征兵优化，原逻辑，征兵过程中兵力发生变化，服务器则发送通知告知客户端，前后端通信频繁。优化后由客户端计算兵力数量，服务器只在征兵开始、征兵取消、征兵速度变化时通知。

（4 征兵优化，前后端存在时差Clock.nowms，导致征兵数量不一致，优化方案分别为客户端固定延迟x ms；服务端定义一个错误码，当前后端数量不一致时，返回错误和延迟时间，延到到xxms后再发送分兵请求。



## 背包系统
背包内包含四种类型的道具，普通道具、武将信物、装备、材料道具。每种道具的用途和获取路径各有不同，需要背包系统内管理道具的数据、使用方法和显示规则。

### 1. 数据层：
Bag 管理所有道具、监听背包变化通知、提供外部调用接口

Item 道具属性的管理，包括道具id、道具格子uid、名称、类型、子类型等等，同事也将通用复杂且独立的逻辑拆分出来，如排序规则、使用请求、红点逻辑等。

ItemOperation 道具的操作方法

ItemAccess 道具的获取路径

### 2. UI控制层：

UIBagPanel、UIBagDetail、UIBagItem


### 亮点：
（1） 解决道具同时大批量更新时，频繁触发界面刷新造成卡顿的问题（如武将后台招募，道具批量使用），使用脏标记模式，界面需要刷新时在更改布尔值_isDirty，在LateUpdate中每10帧判断一下脏标志位，true则刷新并设置为false。缺点：状态更新滞后，多了标记和每帧检查的开销。

（2） 由于不同的道具的用途类型和用途数量不同，原逻辑是根据道具的子类型和附加参数，switch-case横向扩展了大量的方法和判断逻辑，导致代码的可读性和扩展性较差。为此，提取了道具操作的概念，封装了ItemOpearation，里面包含了道具的操作类型、操作名称、操作权限和操作方法，在创建道具时为其附加所需的道具操作类型，以此链接其具有的操作方法或可执行方法；通过将道具操作分离，背包模块在后续开发时更易进行扩展和维护。

（3）背包界面的屏幕适配和道具特效的显示层级问题。


## 选服/选角系统
在进入游戏前，玩家可在登录界面选择角色和选择服务器，且开发环境、提审环境、以及正式环境下所展示的区服信息和进入游戏的权限限制都不一样。

### 1. 选服 HostAddressesRequest：
负责从目录服请求区服数据，并在本地加载和显示。

需在本地预定义数据格式，利用LitJson库将拉取到的json格式的字符串反序列化为C#对象，每个区服信息都需再转换为客户端存储和使用HostAddreses对象，共同存放在asset文件HostAddresseses中，作为数据层控制玩家的选服操作。

HostAddreses中存储了区服的zoneId、Ip、端口号、在线人数、注册人数、鉴权权限（用于判断进入游戏是否需要登录SDK，相当于实名）等。

### 2. 选服流程

（1）游戏加载时，判断当前是否是编辑器环境，是则直接发起区服数据请求，否则等待SDK弹出的窗口关闭（即玩家实名信息确认完毕）再发起区服数据请求。

（2）调用延时加载转圈界面，如果0.5s后请求数据失败则调起该界面

（3）根据当前环境向对应的Ip地址发起区服数据请求，try-catch捕获这一过程中发生的异常，如果请求数据成功，则正常注入到HostAddresses配置中，作为后续选服界面的数据源，如果请求数据失败或者触发异常，则根据设置再次重新发起请求直到成功或达到请求次数上限为止。

（4） 进入登录界面，如果区服数据已获取，则根据玩家的上次本地缓存或者推荐规则展示默认选中的区服信息，否则为空白，玩家点击进入游戏时弹出提示窗，再次尝试重新请求区服数据。

### 3. 请求区服数据的通信准备

（1） 准备客户端的用户数据（平台id、sdk账号id、版本信息），转换成base64传给服务器。

（2） 将当前时间戳、账号id和token用私钥加密，（RSA加密+SHA1签名）进行数字签名，将参数和签名添加到header中传给服务器，验证通过则返回数据。

（3） 在Debug模式和编辑器模式下跳过证书验证，因为Http的证书可能过期，重写request.certificateHandler。

### 4. 选角 AccountRolesRequest 

负责从目录服请求角色数据，并在本地加载显示。

与区服数据不同，它是打开选服界面的时候开始请求角色数据，请求成功后再在界面上刷新展示出来，保证打开界面时看到的信息是最新的。



## 充值相关

### 充值流程：
1. 游戏客户端  判断玩家是否有充值权限（游客无法充值），准备充值相关数据传入SDK接口，调起SDK客户端。
2. SDK客户端，向充值服务器请求创建支付订单。
3. 充值服务器，返回订单信息到SDK客户端。
4. SDK客户端 调起渠道客户端，支付请求，渠道服务器返回支付结果。
5. （1）渠道服务器将结果传递给渠道客户端   渠道客户端传递给游戏客户端;
（2）渠道服务器将结果传递给充值服务器，充值服务器通知游戏服务端。
6. 游戏服务器向游戏客户端发送新订单生成通知 CS_MSG.NtyOrderpay
7. 游戏客户端接收通知，向服务器请求核销订单数据，先获取订单，再发起校验请求。
GetOrdersReq, GetOrdersRsp   VerifyOrderReq, VerifyOrderRsp
8. （1）客户端和服务器校验通过，客户端修改校验状态，服务器发放奖励。
（2）校验不通过，如订单过期，则跳过。
9. 登录时会再次发起订单核销请求，处理未核销订单。

### 赠送支付流程：
客户端向服务器发起赠送请求，等待服务器验证 PayGivePresentsReq, PayGivePresentsRsp。
服务器返回giveId，一并传入SDK中，进行充值流程。
多出的流程用于防止用户篡改网络传输的数据，更改赠送对象。

## 实体管理

- 统一的“世界实体”数据模型：承载标识、类型、位置、规模、归属、状态、外观、城池/守军/阵型/士气/路径/驻扎/计策等丰富信息，并带有一组便捷查询属性（如是否移动、是否自己、是否免战中等）。

- 行为入口：Appear/Disappear/Enter/Exit 等操作由 Entity 调用，但实际逻辑由全局管理器 Entities 执行。

- 分部类扩展：Entity 为 partial，功能分散在多个文件（如 FamilyDungeon/Sensor/Structure/Operation），按功能域拆分。

### 创建流程（Enter/Appear 流程）

- 外部通过 Entities.Create(entity) 或 Entities.Enter(entity) 驱动创建；Create 只是转调 Enter。

- Enter 核心步骤：
（1）参数校验（类型不得为 None）；
（2）查找是否已有旧实例；通过 Baker.instance.Bake(payload) 对入参进行“烘焙”标准化；
（3）运行连接/托管判定（EntityConnect.Run、EntityHost.Run），某些情况下会转为连接或托管更新并提前返回；
（4）若已有旧实例则先安全 Exit
（5）写入全局容器 entities[id]，推入 Buckets，记录日志
（6）分发到按类型路由的模块 module.Enter(to)（如 TroopEntities、CityEntities 等）
（7）经过“大坝”_dam.Enter 的显示节流/延迟控制
（8）触发 Appear 事件（enter?.Invoke(entity)），让表现层响应。

### 全局管理器 （Entities）

- 单例总线：Entities : Singleton<Entities>, GenealogyListener。维护三类容器：
entities: Dictionary<long, Entity> 全量实体索引
groups: Dictionary<EntityType, EntityModule> 类型到模块的路由
modules: Dictionary<Type, EntityModule> 直接按模块类型索引

- 模块化分发：不同 EntityType 映射到不同 EntityModule（如 TroopEntities、CityEntities、OutpostEntities 等），负责各自类型的进入/离开等侧逻辑。

- 事件机制：提供 enter/exit/establish/instruct/operate/repair 六类事件，驱动 UI、监听器与玩法模块。

- 大坝节流：EntityDam 统一控制实体显示出入的节奏（如批量进入/离开时做抽帧/延迟），Enter/Exit 均会经过 _dam。

- EntityInstruction（指令，逻辑状态变更）
作用：对某个实体执行一条“逻辑指令”，驱动实体的逻辑状态或子模块变化（如连接、占领、兵力调整、敌对标记、执行动作等）。
触发：调用其 Dispatch()，进入“大坝”排队，随后由 Entities.Instruct(...) 分发到具体执行上下文 EntityInstructor 与各玩法侧监听。
关键点：支持 discard 丢弃标记；进入实体的 instruct 调试列表（DEBUG_V）。

- EntityOperation（操作，表现/交互侧操作事件）
作用：更偏“操作事件/交互回声”，例如玩家下发命令后，触发音效与UI/表现层联动；不是直接修改实体内部数据结构的“指令”，而是广播一次“已操作”的事件。
触发：通常由服务端应答后调用 EntityOperation.Dispatch(id, order)，播放音效并发布事件，进入“大坝”后转给 Entities.Operate(...)，由订阅方（如Pawn、UI）响应。

- EntityPatch（补丁，数据修复/纠偏）
作用：对实体进行“纠偏/修复”的数据级更新，常用于对客户端实体状态与服务器真实状态的同步修正（如耐久、部署状态、驻扎/路径校正等）。
触发：调用 Dispatch() 进入“大坝”，随后 Entities.Repair(...) 经 EntityPatcher 执行具体修复；支持 ignore 忽略标记。


## 游戏启动流程

LaunchScene.cs

1. 设置游戏版本管理器GUpdateManager
2. 游戏开始加载本地配置文件
LoadLocalVersionConfig()
SDKInitialize()
3. 加载资源补丁更新界面，开始热更 Initialize()
4. 初始化预制体，挂载App预制体Launch()

AppMain.cs

5. 日志、UI、配置表、资源、声音等加载和初始化 Initialize()、Load()。。
App.instance.Initialize(); 收集[AppLoad]等特性标记的方法，主要用于监听服务器主动下发的消息。
在App.instance.Load();中执行被特性标记的方法。
6. 进入新场景world.scene，打开游戏加载界面UIPanels.Show<UILoginLoading>()
巨人弹窗 GiantSDKEngine.Instance.Login(userinfoJson is { Length: > 2 }, null);
打开游戏登录界面UILoginPanel

UILoginPanel.cs

7. 点击登录，连接分区服务器，发送登录请求
8. User.cs（静态类），接收服务器下发的进入游戏通知（EnterGameEndNty），执行OnLoad，包括各IUserModule的初始化加载，以及Launch方法（关闭登录界面）

