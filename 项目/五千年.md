# 项目框架
--------------

## UGUI
### 一 UI Panel


### 二 图集
#### 2.1 图集拆分策略

图集拆分策略​​的核心目标是平衡性能（减少Draw Calls）与内存效率（降低内存峰值）。

(1) 划分私有图集、公共图集。公共图集存放多个模块高频复用的资源，而同一功能/界面​​的临时使用纹理合并到同一私有图集。

(2) 公共图集的添加要慎重,控制公共图集的个数,不是所有的小图都要使用图集，比如物品图标（常伴随游戏逻辑动态变化，打在静态图集中，未使用的图标占比大造成内存浪费。优化方案：动态图集，仅对当前屏幕显示的图标实时打包，避免全量加载）。

(3) 背景图单独一个图集，或者不打图集。

(4) 小图采用九宫格、纯色图片、减少半透明图片；大的的背景图片尽量采用高复用性。

#### 2.2 图集的原理是什么
图集（Texture Atlas）是一种将多个小纹理合并为一张大纹理的技术
图集装箱算法：

（1）断头台算法，Guillotine算法会维护一个剩余矩形list(其中的空白矩形称为F)。主要方法是从uv矩形(称为R)中选出一个放置在F左下角，再将右上方的“L”型空间分割为两个F并组织进list（所以不会有任何一个空白块被忽略）。再递归执行，直到R不能装入list中的任何一个F，则再开一个bin。

（2）最大矩形算法(MaxRects)，保证装箱速度的同时，尽量减少大图的尺寸，从而获得较高的空间利用率。
Guillotine的缺点在于不能跨过分割线，为了解决这个问题，Maximal方法提出了新的分割方式，即同时执行水平分割和竖直分割，并保留两次分割中的包含右上矩形的矩形(或叫maximal矩形)，作为F存入剩余空间list。
https://zhuanlan.zhihu.com/p/375451946


#### 2.3 图集为什么能减低内存
图集最终形成的纹理尺寸变大了，但占用内存减少。原因：

（1）减少了小图的冗余开销，如每张纹理需存储的头部信息（压缩格式元数据），合并图集后只需存一份。

（2）压缩格式的效率提升​，大图集包含更多像素相关性，压缩算法（如ETC2、ASTC）可达到更高压缩。GPU对纹理内存有对齐要求(如4KB/64KB对齐)，并后的大纹理可以更高效地利用对齐空间。

（3） 空白区域的优化处理。

### 

### 三 一个Prefab中包含什么？


## Protobuf


## UIParticle
UIParticle 是 Unity 中用于在 UI 系统上显示粒子特效的解决方案，它解决了原生 ParticleSystem 无法与 UGUI 系统完美整合的问题。

参考：https://zhuanlan.zhihu.com/p/633932778

### UIParticle的作用

1. 让原本为 3D 场景设计的 ParticleSystem 能够被 UI 的 Mask/RectMask2D 裁剪。
2. 支持在 Canvas 下显示，并与UI元素正确叠加排序。
​
### UIParticle的原理
1. 将 ParticleSystem 的渲染输出转化为UI的Mesh(顶点、三角形、UV等)。通过UGUI的渲染管线输出到Canvas。
2. 继承自MaskableGraphic，因此支持所有UGUI的遮罩和裁剪功能。

UIParticle就解决了UGUI与Particle System不兼容的问题，通过在其节点上挂载CanvasRender,然后通过ParticleSystemRenderer的BakeMesh接口将网格传给CanvasRender,做到节点数据跟UGUI的处理方式一致。

### UIParticle的特性和优点
​​无缝UI整合、​​渲染转换机制​​、​​跨平台支持​​、​​高级特效功能​​


## HybridCLR

### HybridCLR的优势：
![alt text](image.png)
HybridCLR是一个特性完整、零成本、高性能、低内存的近乎完美的Unity全平台原生c#热更新解决方案。

（1）特性完整。支持反射、多线程、异步等完整C#特性，与常规Unity开发流程完全一致。

（2）零成本。无需学习其他脚本语言，通过扩充IL2CPP运行时，使其支持"AOT+解释执行"混合模式，热更新代码与原生AOT代码​​类型系统完全统一​​，无需适配器或生成代码。（IL2CPP：C#到中间语言（IL）的转换​，​​IL到C++代码的转换，C++代码由目标平台的本地编译器编译为二进制文件​）

（3）高性能。实现了一个极其高效的寄存器解释器，通过​​差分混合DLL技术​​，未修改代码以AOT模式运行，修改部分解释执行，整体性能比Lua快3-10倍，比ILRuntime快2-5倍。

（4）低内存。热更新脚本中定义的类跟普通c#类占用一样的内存空间，远优于其他热更新方案。

### 不同热更方式的原理

（1）C#热更具体做法：将需要频繁更改的逻辑部分独立出来做成DLL，在主模块调用这些DLL，主模块代码是不修改的，只有作为业务（逻辑）模块的DLL部分需要修改。游戏运行时通过反射机制加载这些DLL就实现了热更新。ILRuntime 就是使用C#进行的热更新。

（2）lua热更原理：逻辑代码转化为脚本，脚本转化为文本资源，以更新资源的形式更新程序。

## 设备性能

### 最低配置：
iOS：A9处理器、内存2G及以上配置设备（iPhone 6s及以上）

安卓：高通骁龙460/麒麟710及以上、内存4g及以上设备

### 品质分级

UnityEngine.SystemInfo 获取设备信息

 * 先判断芯片，再判断内存：
 * 内存lv5：12G+, lv4：12G+, lv3:8G+, lv2:6G+, lv1:4G+, lv0:4G-
 * 有cpu取 cpu评级 有gpu取gpu,都有取最低