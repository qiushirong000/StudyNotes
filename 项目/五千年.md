# 项目框架
--------------

## UGUI
### 一 UI Panel


### 二 图集
#### 2.1 图集拆分策略

图集拆分策略​​的核心目标是平衡性能（减少Draw Calls）与内存效率（降低内存峰值）。

(1) 划分私有图集、公共图集。公共图集存放多个模块高频复用的资源，而同一功能/界面​​的临时使用纹理合并到同一私有图集。

(2) 公共图集的添加要慎重,控制公共图集的个数,不是所有的小图都要使用图集，比如物品图标（常伴随游戏逻辑动态变化，打在静态图集中，未使用的图标占比大造成内存浪费。优化方案：动态图集，仅对当前屏幕显示的图标实时打包，避免全量加载）。

(3) 背景图单独一个图集，或者不打图集。

(4) 小图采用九宫格、纯色图片、减少半透明图片；大的的背景图片尽量采用高复用性。

#### 2.2 图集的原理是什么
图集（Texture Atlas）是一种将多个小纹理合并为一张大纹理的技术
图集装箱算法：

（1）断头台算法，Guillotine算法会维护一个剩余矩形list(其中的空白矩形称为F)。主要方法是从uv矩形(称为R)中选出一个放置在F左下角，再将右上方的“L”型空间分割为两个F并组织进list（所以不会有任何一个空白块被忽略）。再递归执行，直到R不能装入list中的任何一个F，则再开一个bin。

（2）最大矩形算法(MaxRects)，保证装箱速度的同时，尽量减少大图的尺寸，从而获得较高的空间利用率。
Guillotine的缺点在于不能跨过分割线，为了解决这个问题，Maximal方法提出了新的分割方式，即同时执行水平分割和竖直分割，并保留两次分割中的包含右上矩形的矩形(或叫maximal矩形)，作为F存入剩余空间list。
https://zhuanlan.zhihu.com/p/375451946


#### 2.3 图集为什么能减低内存
图集最终形成的纹理尺寸变大了，但占用内存减少。原因：

（1）减少了小图的冗余开销，如每张纹理需存储的头部信息（压缩格式元数据），合并图集后只需存一份。

（2）压缩格式的效率提升​，大图集包含更多像素相关性，压缩算法（如ETC2、ASTC）可达到更高压缩。

（3） 空白区域的优化处理。

### 

### 三 一个Prefab中包含什么？


## Protobuf


## HybridCLR

### HybridCLR的优势：
![alt text](image.png)
HybridCLR是一个特性完整、零成本、高性能、低内存的近乎完美的Unity全平台原生c#热更新解决方案。

（1）特性完整。支持反射、多线程、异步等完整C#特性，与常规Unity开发流程完全一致。

（2）零成本。无需学习其他脚本语言，通过扩充IL2CPP运行时，使其支持"AOT+解释执行"混合模式，热更新代码与原生AOT代码​​类型系统完全统一​​，无需适配器或生成代码。（IL2CPP：C#到中间语言（IL）的转换​，​​IL到C++代码的转换，C++代码由目标平台的本地编译器编译为二进制文件​）

（3）高性能。实现了一个极其高效的寄存器解释器，通过​​差分混合DLL技术​​，未修改代码以AOT模式运行，修改部分解释执行，整体性能比Lua快3-10倍，比ILRuntime快2-5倍。

（4）低内存。热更新脚本中定义的类跟普通c#类占用一样的内存空间，远优于其他热更新方案。

### 不同热更方式的原理

（1）C#热更具体做法：将需要频繁更改的逻辑部分独立出来做成DLL，在主模块调用这些DLL，主模块代码是不修改的，只有作为业务（逻辑）模块的DLL部分需要修改。游戏运行时通过反射机制加载这些DLL就实现了热更新。ILRuntime 就是使用C#进行的热更新。

（2）lua热更原理：逻辑代码转化为脚本，脚本转化为文本资源，以更新资源的形式更新程序。

### 设备性能